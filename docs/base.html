<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scalecodec.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scalecodec.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Python SCALE Codec Library
#
# Copyright 2018-2020 Stichting Polkascan (Polkascan Foundation).
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
import warnings
from abc import ABC, abstractmethod
from typing import Optional, TYPE_CHECKING, Union

from scalecodec.constants import TYPE_DECOMP_MAX_RECURSIVE
from scalecodec.exceptions import RemainingScaleBytesNotEmptyException, InvalidScaleTypeValueException

if TYPE_CHECKING:
    from scalecodec.types import GenericMetadataVersioned, GenericRegistryType


class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):

        if &#39;config_id&#39; in kwargs:
            instance_key = kwargs[&#39;config_id&#39;]
        else:
            instance_key = cls

        if instance_key not in cls._instances:
            cls._instances[instance_key] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[instance_key]


class RuntimeConfigurationObject:

    @classmethod
    def all_subclasses(cls, class_):
        return set(class_.__subclasses__()).union(
            [s for c in class_.__subclasses__() for s in cls.all_subclasses(c)])

    def __init__(self, config_id=None, ss58_format=None, only_primitives_on_init=False, implements_scale_info=False):
        self.config_id = config_id
        self.type_registry = {&#39;types&#39;: {}, &#39;runtime_api&#39;: {}}
        self.__initial_state = False
        self.clear_type_registry()
        self.active_spec_version_id = None
        self.chain_id = None

        self.only_primitives_on_init = only_primitives_on_init
        self.ss58_format = ss58_format
        self.implements_scale_info = implements_scale_info

    @classmethod
    def convert_type_string(cls, name):

        name = re.sub(r&#39;T::&#39;, &#34;&#34;, name)
        name = re.sub(r&#39;^T::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T&gt;&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Trait&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Trait&lt;I&gt;&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Config&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Config&lt;I&gt;&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;\n&#39;, &#34;&#34;, name)
        name = re.sub(r&#39;^(grandpa|session|slashing|limits|beefy_primitives|xcm::opaque)::&#39;, &#34;&#34;, name)
        name = re.sub(r&#39;VecDeque&lt;&#39;, &#34;Vec&lt;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;^Box&lt;(.+)&gt;$&#39;, r&#39;\1&#39;, name, flags=re.IGNORECASE)

        if name == &#39;()&#39;:
            return &#34;Null&#34;
        if name.lower() in [&#39;vec&lt;u8&gt;&#39;, &#39;&amp;[u8]&#39;, &#34;&amp; &#39;static[u8]&#34;]:
            return &#34;Bytes&#34;
        if name.lower() == &#39;&lt;lookup as staticlookup&gt;::source&#39;:
            return &#39;LookupSource&#39;
        if name.lower() == &#39;&lt;balance as hascompact&gt;::type&#39;:
            return &#39;Compact&lt;Balance&gt;&#39;
        if name.lower() == &#39;&lt;blocknumber as hascompact&gt;::type&#39;:
            return &#39;Compact&lt;BlockNumber&gt;&#39;
        if name.lower() == &#39;&lt;moment as hascompact&gt;::type&#39;:
            return &#39;Compact&lt;Moment&gt;&#39;
        if name.lower() == &#39;&lt;inherentofflinereport as inherentofflinereport&gt;::inherent&#39;:
            return &#39;InherentOfflineReport&#39;

        return name

    def get_decoder_class(self, type_string: Union[str, dict]):

        if type(type_string) is dict:
            # Inner struct
            decoder_class = type(&#39;InnerStruct&#39;, (self.get_decoder_class(&#39;Struct&#39;),), {
                &#39;type_mapping&#39;: tuple(type_string.items())
            })
            decoder_class.runtime_config = self
            return decoder_class

        if type_string.strip() == &#39;&#39;:
            return None

        if self.implements_scale_info is False:
            type_string = self.convert_type_string(type_string)

        decoder_class = self.type_registry.get(&#39;types&#39;, {}).get(type_string.lower(), None)

        if not decoder_class:

            # Type string containg subtype
            if type_string[-1:] == &#39;&gt;&#39;:

                # Extract sub types
                type_parts = re.match(r&#39;^([^&lt;]*)&lt;(.+)&gt;$&#39;, type_string)

                if type_parts:
                    type_parts = type_parts.groups()

                if type_parts:
                    # Create dynamic class for Part1&lt;Part2&gt; based on Part1 and set class variable Part2 as sub_type
                    base_class = self.type_registry.get(&#39;types&#39;, {}).get(type_parts[0].lower(), None)
                    if base_class:
                        decoder_class = type(type_string, (base_class,), {&#39;sub_type&#39;: type_parts[1]})

            # Custom tuples
            elif type_string != &#39;()&#39; and type_string[0] == &#39;(&#39; and type_string[-1] == &#39;)&#39;:

                decoder_class = type(type_string, (self.get_decoder_class(&#39;tuple&#39;),), {
                    &#39;type_string&#39;: type_string
                })

                decoder_class.build_type_mapping()

            elif type_string[0] == &#39;[&#39; and type_string[-1] == &#39;]&#39;:
                type_parts = re.match(r&#39;^\[([A-Za-z0-9]+); ([0-9]+)\]$&#39;, type_string)

                if type_parts:
                    type_parts = type_parts.groups()

                if type_parts:
                    # Create dynamic class for e.g. [u8; 4] resulting in array of u8 with 4 elements
                    decoder_class = type(type_string, (self.get_decoder_class(&#39;FixedLengthArray&#39;),), {
                        &#39;sub_type&#39;: type_parts[0],
                        &#39;element_count&#39;: int(type_parts[1])
                    })

        if decoder_class:
            # Attach RuntimeConfigurationObject to new class
            decoder_class.runtime_config = self

        return decoder_class

    def create_scale_object(self, type_string: str, data: Optional[&#39;ScaleBytes&#39;] = None, **kwargs) -&gt; &#39;ScaleType&#39;:
        &#34;&#34;&#34;
        Creates a new `ScaleType` object with given type_string, for example &#39;u32&#39;, &#39;Bytes&#39; or &#39;scale_info::2&#39;
        (scale_info:: prefixed types are defined in the `PortableRegistry` object of the runtime metadata.)

        Parameters
        ----------
        type_string: string representation of a `ScaleType`
        data: ScaleBytes data to decode
        kwargs

        Returns
        -------
        ScaleType
        &#34;&#34;&#34;
        decoder_class = self.get_decoder_class(type_string)

        if decoder_class:
            return decoder_class(data=data, **kwargs)

        raise NotImplementedError(&#39;Decoder class for &#34;{}&#34; not found&#39;.format(type_string))

    def clear_type_registry(self):

        if not self.__initial_state:
            self.type_registry = {&#39;types&#39;: {}, &#39;runtime_api&#39;: {}}

            # Class names that contains &#39;&lt;&#39; are excluded because of a side effect that is introduced in
            # get_decoder_class: &#34;Create dynamic class for Part1&lt;Part2&gt; based on Part1 and set class variable Part2 as
            # sub_type&#34; which won&#39;t get reset because class definitions always remain globally

            self.type_registry[&#39;types&#39;].update(
                {
                    cls.__name__.lower(): cls for cls in self.all_subclasses(ScaleDecoder)
                    if &#39;&lt;&#39; not in cls.__name__ and &#39;::&#39; not in cls.__name__
                }
            )

        self.__initial_state = True

    def update_type_registry_types(self, types_dict):
        from scalecodec.types import Enum, Struct, Set, Tuple

        self.__initial_state = False

        for type_string, decoder_class_data in types_dict.items():

            if type(decoder_class_data) == dict:

                # Create dynamic decoder class
                base_cls = None

                if decoder_class_data.get(&#39;base_class&#39;):
                    base_cls = self.get_decoder_class(decoder_class_data[&#39;base_class&#39;])
                    if base_cls is None:
                        raise ValueError(f&#34;Specified base_class &#39;{decoder_class_data[&#39;base_class&#39;]}&#39; for type &#34; +
                                         f&#34;&#39;{type_string}&#39; not found&#34;)

                if decoder_class_data[&#39;type&#39;] == &#39;struct&#39;:

                    if base_cls is None:
                        base_cls = Struct

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                    })

                elif decoder_class_data[&#39;type&#39;] == &#39;tuple&#39;:

                    if base_cls is None:
                        base_cls = Tuple

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                    })

                elif decoder_class_data[&#39;type&#39;] == &#39;enum&#39;:

                    if base_cls is None:
                        base_cls = Enum

                    value_list = decoder_class_data.get(&#39;value_list&#39;)

                    if type(value_list) is dict:
                        # Transform value_list with explicitly specified index numbers
                        value_list = {i: v for v, i in value_list.items()}

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;value_list&#39;: value_list,
                        &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                    })

                elif decoder_class_data[&#39;type&#39;] == &#39;set&#39;:

                    if base_cls is None:
                        base_cls = Set

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;value_list&#39;: decoder_class_data.get(&#39;value_list&#39;),
                        &#39;value_type&#39;: decoder_class_data.get(&#39;value_type&#39;, &#39;u64&#39;)
                    })

                else:
                    raise NotImplementedError(&#34;Dynamic decoding type &#39;{}&#39; not supported&#34;.format(
                        decoder_class_data[&#39;type&#39;])
                    )
            else:
                decoder_class = self.get_decoder_class(decoder_class_data)

            self.type_registry[&#39;types&#39;][type_string.lower()] = decoder_class

    def update_type_registry(self, type_registry):

        # Set runtime ID if set
        self.active_spec_version_id = type_registry.get(&#39;runtime_id&#39;)

        # Set chain ID if set
        self.chain_id = type_registry.get(&#39;chain_id&#39;)

        self.type_registry[&#39;versioning&#39;] = type_registry.get(&#39;versioning&#39;)
        self.type_registry[&#39;runtime_api&#39;].update(type_registry.get(&#39;runtime_api&#39;, {}))
        self.type_registry[&#39;runtime_upgrades&#39;] = type_registry.get(&#39;runtime_upgrades&#39;)

        # Update types
        if &#39;types&#39; in type_registry:
            self.update_type_registry_types(type_registry.get(&#39;types&#39;))

    def set_active_spec_version_id(self, spec_version_id):

        if spec_version_id != self.active_spec_version_id:

            self.active_spec_version_id = spec_version_id

            # Updated type registry with versioned types
            for versioning_item in self.type_registry.get(&#39;versioning&#39;) or []:
                # Check if versioning item is in current version range
                if versioning_item[&#39;runtime_range&#39;][0] &lt;= spec_version_id and \
                        (not versioning_item[&#39;runtime_range&#39;][1] or versioning_item[&#39;runtime_range&#39;][1] &gt;= spec_version_id):
                    # Update types in type registry
                    self.update_type_registry_types(versioning_item[&#39;types&#39;])

    def get_runtime_id_from_upgrades(self, block_number: int) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Retrieve runtime_id for given block_number if runtime_upgrades are specified in the type registry

        Parameters
        ----------
        block_number

        Returns
        -------
        Runtime id
        &#34;&#34;&#34;
        if self.type_registry.get(&#39;runtime_upgrades&#39;):

            if block_number &gt; self.type_registry[&#39;runtime_upgrades&#39;][-1][0]:
                return

            for max_block_number, runtime_id in reversed(self.type_registry[&#39;runtime_upgrades&#39;]):
                if block_number &gt;= max_block_number and runtime_id != -1:
                    return runtime_id

    def set_runtime_upgrades_head(self, block_number: int):
        &#34;&#34;&#34;
        Sets head for given block_number to last runtime_id in runtime_upgrades cache

        Parameters
        ----------
        block_number

        Returns
        -------

        &#34;&#34;&#34;
        if self.type_registry.get(&#39;runtime_upgrades&#39;):
            if self.type_registry[&#39;runtime_upgrades&#39;][-1][1] == -1:
                self.type_registry[&#39;runtime_upgrades&#39;][-1][0] = block_number
            elif block_number &gt; self.type_registry[&#39;runtime_upgrades&#39;][-1][0]:
                self.type_registry[&#39;runtime_upgrades&#39;].append([block_number, -1])

    def get_decoder_class_for_scale_info_definition(
            self, type_string: str, scale_info_type: &#39;GenericRegistryType&#39;, prefix: str
    ):

        decoder_class = None
        base_decoder_class = None

        # Check if base decoder class is defined for path
        if &#39;path&#39; in scale_info_type.value and len(scale_info_type.value[&#39;path&#39;]) &gt; 0:
            path_string = &#39;::&#39;.join(scale_info_type.value[&#34;path&#34;])
            base_decoder_class = self.get_decoder_class(path_string)

            if base_decoder_class is None:

                # Try wildcard type
                catch_all_path = &#39;*::&#39; + &#39;::&#39;.join(scale_info_type.value[&#34;path&#34;][1:])
                base_decoder_class = self.get_decoder_class(catch_all_path)

                if base_decoder_class is None:
                    # Try catch-all type
                    catch_all_path = &#39;*::&#39; * (len(scale_info_type.value[&#39;path&#39;]) - 1) + scale_info_type.value[&#34;path&#34;][-1]
                    base_decoder_class = self.get_decoder_class(catch_all_path)

            if base_decoder_class and hasattr(base_decoder_class, &#39;process_scale_info_definition&#39;):
                # if process_scale_info_definition is implemented result is final
                decoder_class = type(type_string, (base_decoder_class,), {})
                decoder_class.process_scale_info_definition(scale_info_type, prefix)

                # Link ScaleInfo RegistryType to decoder class
                decoder_class.scale_info_type = scale_info_type

                return decoder_class

        if &#34;primitive&#34; in scale_info_type.value[&#34;def&#34;]:
            decoder_class = self.get_decoder_class(scale_info_type.value[&#34;def&#34;][&#34;primitive&#34;])

        elif &#39;array&#39; in scale_info_type.value[&#39;def&#39;]:

            if base_decoder_class is None:
                base_decoder_class = self.get_decoder_class(&#39;FixedLengthArray&#39;)

            decoder_class = type(type_string, (base_decoder_class,), {
                &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;array&#39;][&#39;type&#39;]}&#34;,
                &#39;element_count&#39;: scale_info_type.value[&#39;def&#39;][&#39;array&#39;][&#39;len&#39;]
            })

        elif &#39;composite&#39; in scale_info_type.value[&#39;def&#39;]:

            type_mapping = []

            base_type_string = &#39;Tuple&#39;

            if &#39;fields&#39; in scale_info_type.value[&#39;def&#39;][&#39;composite&#39;]:

                fields = scale_info_type.value[&#39;def&#39;][&#39;composite&#39;][&#39;fields&#39;]

                if all([f.get(&#39;name&#39;) for f in fields]):
                    base_type_string = &#39;Struct&#39;
                    type_mapping = [[field[&#39;name&#39;], f&#34;{prefix}::{field[&#39;type&#39;]}&#34;] for field in fields]

                else:
                    base_type_string = &#39;Tuple&#39;
                    type_mapping = [f&#34;{prefix}::{field[&#39;type&#39;]}&#34; for field in fields]

            if base_decoder_class is None:
                base_decoder_class = self.get_decoder_class(base_type_string)

            decoder_class = type(type_string, (base_decoder_class,), {
                &#39;type_mapping&#39;: type_mapping
            })

        elif &#39;sequence&#39; in scale_info_type.value[&#39;def&#39;]:
            # Vec
            decoder_class = type(type_string, (self.get_decoder_class(&#39;Vec&#39;),), {
                &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;sequence&#39;][&#39;type&#39;]}&#34;
            })

        elif &#39;variant&#39; in scale_info_type.value[&#39;def&#39;]:
            # Enum
            type_mapping = []

            variants = scale_info_type.value[&#39;def&#39;][&#39;variant&#39;][&#39;variants&#39;]

            if len(variants) &gt; 0:
                # Create placeholder list
                variant_length = max([v[&#39;index&#39;] for v in variants]) + 1
                type_mapping = [(None, &#39;Null&#39;)] * variant_length

                for variant in variants:

                    if &#39;fields&#39; in variant:
                        if len(variant[&#39;fields&#39;]) == 0:
                            enum_value = &#39;Null&#39;
                        elif all([f.get(&#39;name&#39;) for f in variant[&#39;fields&#39;]]):
                            # Enum with named fields
                            enum_value = {f.get(&#39;name&#39;): f&#34;{prefix}::{f[&#39;type&#39;]}&#34; for f in variant[&#39;fields&#39;]}
                        else:
                            if len(variant[&#39;fields&#39;]) == 1:
                                enum_value = f&#34;{prefix}::{variant[&#39;fields&#39;][0][&#39;type&#39;]}&#34;
                            else:
                                field_str = &#39;, &#39;.join([f&#34;{prefix}::{f[&#39;type&#39;]}&#34; for f in variant[&#39;fields&#39;]])
                                enum_value = f&#34;({field_str})&#34;
                    else:
                        enum_value = &#39;Null&#39;

                    # Put mapping in right order in list
                    type_mapping[variant[&#39;index&#39;]] = (variant[&#39;name&#39;], enum_value)

            if base_decoder_class is None:
                base_decoder_class = self.get_decoder_class(&#34;Enum&#34;)

            decoder_class = type(type_string, (base_decoder_class,), {
                &#39;type_mapping&#39;: type_mapping
            })

        elif &#39;tuple&#39; in scale_info_type.value[&#39;def&#39;]:

            type_mapping = [f&#34;{prefix}::{f}&#34; for f in scale_info_type.value[&#39;def&#39;][&#39;tuple&#39;]]

            decoder_class = type(type_string, (self.get_decoder_class(&#39;Tuple&#39;),), {
                &#39;type_mapping&#39;: type_mapping
            })

        elif &#39;compact&#39; in scale_info_type.value[&#39;def&#39;]:
            # Compact
            decoder_class = type(type_string, (self.get_decoder_class(&#39;Compact&#39;),), {
                &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;compact&#39;][&#39;type&#39;]}&#34;
            })

        elif &#39;phantom&#39; in scale_info_type.value[&#39;def&#39;]:
            decoder_class = type(type_string, (self.get_decoder_class(&#39;Null&#39;),), {})

        elif &#39;bitsequence&#39; in scale_info_type.value[&#39;def&#39;]:
            decoder_class = type(type_string, (self.get_decoder_class(&#39;BitVec&#39;),), {})

        else:
            raise NotImplementedError(f&#34;RegistryTypeDef {scale_info_type.value[&#39;def&#39;]} not implemented&#34;)

        # if &#39;path&#39; in scale_info_type.value:
        #     decoder_class.type_string = &#39;::&#39;.join(scale_info_type.value[&#39;path&#39;])

        # Link ScaleInfo RegistryType to decoder class

        decoder_class.scale_info_type = scale_info_type

        return decoder_class

    def update_from_scale_info_types(self, scale_info_types: list, prefix: str = None):

        if prefix is None:
            prefix = &#39;scale_info&#39;

        for scale_info_type in scale_info_types:

            idx = scale_info_type[&#39;id&#39;].value

            type_string = f&#34;{prefix}::{idx}&#34;

            decoder_class = self.get_decoder_class_for_scale_info_definition(
                type_string, scale_info_type[&#39;type&#39;], prefix
            )

            if decoder_class is None:
                raise NotImplementedError(f&#34;No decoding class found for scale type {idx}&#34;)

            if decoder_class:
                self.type_registry[&#39;types&#39;][type_string] = decoder_class

                if len(scale_info_type[&#39;type&#39;].value.get(&#39;path&#39;, [])) &gt; 0:
                    path_string = &#39;::&#39;.join(scale_info_type[&#39;type&#39;].value[&#39;path&#39;]).lower()
                    self.type_registry[&#39;types&#39;][path_string] = decoder_class

    def add_portable_registry(self, metadata: &#39;GenericMetadataVersioned&#39;, prefix=None):

        scale_info_types = metadata.portable_registry.value_object[&#39;types&#39;].value_object

        self.update_from_scale_info_types(scale_info_types, prefix=prefix)

        # Todo process extrinsic types
        pass

    def add_contract_metadata_dict_to_type_registry(self, metadata_dict):
        # TODO
        prefix = f&#34;ink::{metadata_dict[&#39;source&#39;][&#39;hash&#39;]}&#34;
        return self.update_from_scale_info_types(metadata_dict[&#39;types&#39;], prefix=prefix)


class ScaleBytes:

    def __init__(self, data: Union[str, bytes, bytearray]):
        self.offset = 0

        if type(data) is bytearray:
            self.data = data
        elif type(data) is bytes:
            self.data = bytearray(data)
        elif type(data) is str and data[0:2] == &#39;0x&#39;:
            self.data = bytearray.fromhex(data[2:])
        else:
            raise ValueError(&#34;Provided data is not in supported format: provided &#39;{}&#39;&#34;.format(type(data)))

        self.length = len(self.data)

    def get_next_bytes(self, length: int) -&gt; bytearray:
        data = self.data[self.offset:self.offset + length]
        self.offset += length
        return data

    def get_remaining_bytes(self) -&gt; bytearray:
        data = self.data[self.offset:]
        self.offset = self.length
        return data

    def get_remaining_length(self) -&gt; int:
        return self.length - self.offset

    def reset(self):
        self.offset = 0

    def __str__(self):
        return &#34;0x{}&#34;.format(self.data.hex())

    def __eq__(self, other):
        if not hasattr(other, &#39;data&#39;):
            return False
        return self.data == other.data

    def __len__(self):
        return len(self.data)

    def __repr__(self):
        return &#34;&lt;{}(data=0x{})&gt;&#34;.format(self.__class__.__name__, self.data.hex())

    def __add__(self, data):

        if type(data) == ScaleBytes:
            return ScaleBytes(self.data + data.data)

        if type(data) == bytes:
            data = bytearray(data)
        elif type(data) == str and data[0:2] == &#39;0x&#39;:
            data = bytearray.fromhex(data[2:])

        if type(data) == bytearray:
            return ScaleBytes(self.data + data)

    def to_hex(self) -&gt; str:
        return f&#39;0x{self.data.hex()}&#39;


class ScaleDecoder(ABC):

    type_string = None

    type_mapping = None

    sub_type = None

    runtime_config = None

    def __init__(self, data: ScaleBytes, sub_type: str = None, runtime_config: RuntimeConfigurationObject = None):

        if sub_type:
            self.sub_type = sub_type

        if self.type_mapping is None and self.type_string:
            self.build_type_mapping()

        if data:
            assert(type(data) == ScaleBytes)

        if runtime_config:
            self.runtime_config = runtime_config

        if not self.runtime_config:
            # if no runtime config is provided, fallback on singleton
            self.runtime_config = RuntimeConfiguration()

        self.data = data

        self.value_object = None
        self.value_serialized = None

        self.decoded = False

        self.data_start_offset = None
        self.data_end_offset = None

    @property
    def value(self):
        # TODO fix
        # if not self.decoded:
        #     self.decode()
        return self.value_serialized

    @value.setter
    def value(self, value):
        self.value_serialized = value

    @staticmethod
    def is_primitive(type_string: str) -&gt; bool:
        return type_string in (&#39;bool&#39;, &#39;u8&#39;, &#39;u16&#39;, &#39;u32&#39;, &#39;u64&#39;, &#39;u128&#39;, &#39;u256&#39;, &#39;i8&#39;, &#39;i16&#39;, &#39;i32&#39;, &#39;i64&#39;, &#39;i128&#39;,
                               &#39;i256&#39;, &#39;h160&#39;, &#39;h256&#39;, &#39;h512&#39;, &#39;[u8; 4]&#39;, &#39;[u8; 4]&#39;, &#39;[u8; 8]&#39;, &#39;[u8; 16]&#39;, &#39;[u8; 32]&#39;,
                               &#39;&amp;[u8]&#39;)

    @classmethod
    def build_type_mapping(cls):

        if cls.type_string and cls.type_string[0] == &#39;(&#39; and cls.type_string[-1] == &#39;)&#39;:
            type_mapping = ()

            tuple_contents = cls.type_string[1:-1]

            # replace subtype types
            sub_types = re.search(r&#39;([A-Za-z]+[&lt;][^&gt;]*[&gt;])&#39;, tuple_contents)
            if sub_types:
                sub_types = sub_types.groups()
                for sub_type in sub_types:
                    tuple_contents = tuple_contents.replace(sub_type, sub_type.replace(&#39;,&#39;, &#39;|&#39;))

            for tuple_element in tuple_contents.split(&#39;,&#39;):
                type_mapping += (tuple_element.strip().replace(&#39;|&#39;, &#39;,&#39;),)

            cls.type_mapping = type_mapping

    def get_next_bytes(self, length) -&gt; bytearray:
        data = self.data.get_next_bytes(length)
        return data

    def get_next_u8(self) -&gt; int:
        return int.from_bytes(self.get_next_bytes(1), byteorder=&#39;little&#39;)

    def get_next_bool(self) -&gt; bool:
        data = self.get_next_bytes(1)
        if data not in [b&#39;\x00&#39;, b&#39;\x01&#39;]:
            raise InvalidScaleTypeValueException(&#39;Invalid value for datatype &#34;bool&#34;&#39;)
        return data == b&#39;\x01&#39;

    def get_remaining_bytes(self) -&gt; bytearray:
        data = self.data.get_remaining_bytes()
        return data

    def get_used_bytes(self) -&gt; bytearray:
        return self.data.data[self.data_start_offset:self.data_end_offset]

    @abstractmethod
    def process(self):
        raise NotImplementedError

    def decode(self, data: ScaleBytes = None, check_remaining=True):

        if data is not None:
            self.decoded = False
            self.data = data

        if not self.decoded:

            self.data_start_offset = self.data.offset
            self.value_serialized = self.process()
            self.decoded = True

            if self.value_object is None:
                # Default for value_object if not explicitly defined
                self.value_object = self.value_serialized

            self.data_end_offset = self.data.offset

            if check_remaining and self.data.offset != self.data.length:
                raise RemainingScaleBytesNotEmptyException(
                    f&#39;Decoding &lt;{self.__class__.__name__}&gt; - Current offset: {self.data.offset} / length: {self.data.length}&#39;
                )

            if self.data.offset &gt; self.data.length:
                raise RemainingScaleBytesNotEmptyException(
                    f&#39;Decoding &lt;{self.__class__.__name__}&gt; - No more bytes available (needed: {self.data.offset} / total: {self.data.length})&#39;
                )

        return self.value

    def __str__(self):
        return str(self.serialize()) or &#39;&#39;

    def __repr__(self):
        return &#34;&lt;{}(value={})&gt;&#34;.format(self.__class__.__name__, self.serialize())

    def encode(self, value=None):

        if value and issubclass(self.__class__, value.__class__):
            # Accept instance of current class directly
            self.data = value.data
            self.value_object = value.value_object
            self.value_serialized = value.value_serialized
            return value.data

        if value is not None:
            self.value_serialized = value
            self.decoded = True

        self.data = self.process_encode(self.value_serialized)

        if self.value_object is None:
            self.value_object = self.value_serialized

        return self.data

    def process_encode(self, value) -&gt; ScaleBytes:
        raise NotImplementedError(&#34;Encoding not implemented for this ScaleType&#34;)

    @classmethod
    def get_decoder_class(cls, type_string, data=None, runtime_config=None, **kwargs):
        &#34;&#34;&#34;

        Parameters
        ----------
        type_string
        data
        runtime_config
        kwargs

        Returns
        -------
        ScaleType
        &#34;&#34;&#34;

        warnings.warn(&#34;Use RuntimeConfigurationObject.create_scale_object() instead&#34;, DeprecationWarning)

        if not runtime_config:
            runtime_config = RuntimeConfiguration()

        decoder_class = runtime_config.get_decoder_class(
            type_string
        )
        if decoder_class:
            return decoder_class(data=data, runtime_config=runtime_config, **kwargs)

        raise NotImplementedError(&#39;Decoder class for &#34;{}&#34; not found&#39;.format(type_string))

    # TODO rename to decode_type (confusing when encoding is introduced)
    def process_type(self, type_string, **kwargs):
        obj = self.runtime_config.create_scale_object(type_string, self.data, **kwargs)
        obj.decode(check_remaining=False)
        return obj

    def serialize(self):
        return self.value_serialized

    @classmethod
    def convert_type(cls, name):
        return RuntimeConfigurationObject.convert_type_string(name)


class RuntimeConfiguration(RuntimeConfigurationObject, metaclass=Singleton):
    pass


class ScaleType(ScaleDecoder, ABC):

    scale_info_type: &#39;GenericRegistryType&#39; = None

    def __init__(self, data=None, sub_type=None, metadata=None, runtime_config=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        data: ScaleBytes
        sub_type: str
        metadata: VersionedMetadata
        runtime_config: RuntimeConfigurationObject
        &#34;&#34;&#34;
        self.metadata = metadata

        # Container for meta information
        self.meta_info: dict = {}

        if not data:
            data = ScaleBytes(bytearray())
        super().__init__(data, sub_type, runtime_config=runtime_config)

    def __getitem__(self, item):
        return self.value_object[item]

    def __iter__(self):
        for item in self.value_object:
            yield item

    def __eq__(self, other):
        if isinstance(other, ScaleType):
            return other.value_serialized == self.value_serialized
        else:
            return other == self.value_serialized

    def __gt__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &gt; other.value_serialized
        else:
            return self.value_serialized &gt; other

    def __ge__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &gt;= other.value_serialized
        else:
            return self.value_serialized &gt;= other

    def __lt__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &lt; other.value_serialized
        else:
            return self.value_serialized &lt; other

    def __le__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &lt;= other.value_serialized
        else:
            return self.value_serialized &lt;= other

    @classmethod
    def generate_type_decomposition(cls, _recursion_level: int = 0, max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE):
        return cls.__name__


class ScalePrimitive(ScaleType, ABC):

    @classmethod
    def generate_type_decomposition(cls, _recursion_level: int = 0, max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE):
        return cls.__name__.lower()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scalecodec.base.RuntimeConfiguration"><code class="flex name class">
<span>class <span class="ident">RuntimeConfiguration</span></span>
<span>(</span><span>config_id=None, ss58_format=None, only_primitives_on_init=False, implements_scale_info=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuntimeConfiguration(RuntimeConfigurationObject, metaclass=Singleton):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.RuntimeConfigurationObject" href="#scalecodec.base.RuntimeConfigurationObject">RuntimeConfigurationObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.RuntimeConfigurationObject" href="#scalecodec.base.RuntimeConfigurationObject">RuntimeConfigurationObject</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.create_scale_object" href="#scalecodec.base.RuntimeConfigurationObject.create_scale_object">create_scale_object</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.get_runtime_id_from_upgrades" href="#scalecodec.base.RuntimeConfigurationObject.get_runtime_id_from_upgrades">get_runtime_id_from_upgrades</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.set_runtime_upgrades_head" href="#scalecodec.base.RuntimeConfigurationObject.set_runtime_upgrades_head">set_runtime_upgrades_head</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject"><code class="flex name class">
<span>class <span class="ident">RuntimeConfigurationObject</span></span>
<span>(</span><span>config_id=None, ss58_format=None, only_primitives_on_init=False, implements_scale_info=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuntimeConfigurationObject:

    @classmethod
    def all_subclasses(cls, class_):
        return set(class_.__subclasses__()).union(
            [s for c in class_.__subclasses__() for s in cls.all_subclasses(c)])

    def __init__(self, config_id=None, ss58_format=None, only_primitives_on_init=False, implements_scale_info=False):
        self.config_id = config_id
        self.type_registry = {&#39;types&#39;: {}, &#39;runtime_api&#39;: {}}
        self.__initial_state = False
        self.clear_type_registry()
        self.active_spec_version_id = None
        self.chain_id = None

        self.only_primitives_on_init = only_primitives_on_init
        self.ss58_format = ss58_format
        self.implements_scale_info = implements_scale_info

    @classmethod
    def convert_type_string(cls, name):

        name = re.sub(r&#39;T::&#39;, &#34;&#34;, name)
        name = re.sub(r&#39;^T::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T&gt;&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Trait&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Trait&lt;I&gt;&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Config&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;&lt;T as Config&lt;I&gt;&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;\n&#39;, &#34;&#34;, name)
        name = re.sub(r&#39;^(grandpa|session|slashing|limits|beefy_primitives|xcm::opaque)::&#39;, &#34;&#34;, name)
        name = re.sub(r&#39;VecDeque&lt;&#39;, &#34;Vec&lt;&#34;, name, flags=re.IGNORECASE)
        name = re.sub(r&#39;^Box&lt;(.+)&gt;$&#39;, r&#39;\1&#39;, name, flags=re.IGNORECASE)

        if name == &#39;()&#39;:
            return &#34;Null&#34;
        if name.lower() in [&#39;vec&lt;u8&gt;&#39;, &#39;&amp;[u8]&#39;, &#34;&amp; &#39;static[u8]&#34;]:
            return &#34;Bytes&#34;
        if name.lower() == &#39;&lt;lookup as staticlookup&gt;::source&#39;:
            return &#39;LookupSource&#39;
        if name.lower() == &#39;&lt;balance as hascompact&gt;::type&#39;:
            return &#39;Compact&lt;Balance&gt;&#39;
        if name.lower() == &#39;&lt;blocknumber as hascompact&gt;::type&#39;:
            return &#39;Compact&lt;BlockNumber&gt;&#39;
        if name.lower() == &#39;&lt;moment as hascompact&gt;::type&#39;:
            return &#39;Compact&lt;Moment&gt;&#39;
        if name.lower() == &#39;&lt;inherentofflinereport as inherentofflinereport&gt;::inherent&#39;:
            return &#39;InherentOfflineReport&#39;

        return name

    def get_decoder_class(self, type_string: Union[str, dict]):

        if type(type_string) is dict:
            # Inner struct
            decoder_class = type(&#39;InnerStruct&#39;, (self.get_decoder_class(&#39;Struct&#39;),), {
                &#39;type_mapping&#39;: tuple(type_string.items())
            })
            decoder_class.runtime_config = self
            return decoder_class

        if type_string.strip() == &#39;&#39;:
            return None

        if self.implements_scale_info is False:
            type_string = self.convert_type_string(type_string)

        decoder_class = self.type_registry.get(&#39;types&#39;, {}).get(type_string.lower(), None)

        if not decoder_class:

            # Type string containg subtype
            if type_string[-1:] == &#39;&gt;&#39;:

                # Extract sub types
                type_parts = re.match(r&#39;^([^&lt;]*)&lt;(.+)&gt;$&#39;, type_string)

                if type_parts:
                    type_parts = type_parts.groups()

                if type_parts:
                    # Create dynamic class for Part1&lt;Part2&gt; based on Part1 and set class variable Part2 as sub_type
                    base_class = self.type_registry.get(&#39;types&#39;, {}).get(type_parts[0].lower(), None)
                    if base_class:
                        decoder_class = type(type_string, (base_class,), {&#39;sub_type&#39;: type_parts[1]})

            # Custom tuples
            elif type_string != &#39;()&#39; and type_string[0] == &#39;(&#39; and type_string[-1] == &#39;)&#39;:

                decoder_class = type(type_string, (self.get_decoder_class(&#39;tuple&#39;),), {
                    &#39;type_string&#39;: type_string
                })

                decoder_class.build_type_mapping()

            elif type_string[0] == &#39;[&#39; and type_string[-1] == &#39;]&#39;:
                type_parts = re.match(r&#39;^\[([A-Za-z0-9]+); ([0-9]+)\]$&#39;, type_string)

                if type_parts:
                    type_parts = type_parts.groups()

                if type_parts:
                    # Create dynamic class for e.g. [u8; 4] resulting in array of u8 with 4 elements
                    decoder_class = type(type_string, (self.get_decoder_class(&#39;FixedLengthArray&#39;),), {
                        &#39;sub_type&#39;: type_parts[0],
                        &#39;element_count&#39;: int(type_parts[1])
                    })

        if decoder_class:
            # Attach RuntimeConfigurationObject to new class
            decoder_class.runtime_config = self

        return decoder_class

    def create_scale_object(self, type_string: str, data: Optional[&#39;ScaleBytes&#39;] = None, **kwargs) -&gt; &#39;ScaleType&#39;:
        &#34;&#34;&#34;
        Creates a new `ScaleType` object with given type_string, for example &#39;u32&#39;, &#39;Bytes&#39; or &#39;scale_info::2&#39;
        (scale_info:: prefixed types are defined in the `PortableRegistry` object of the runtime metadata.)

        Parameters
        ----------
        type_string: string representation of a `ScaleType`
        data: ScaleBytes data to decode
        kwargs

        Returns
        -------
        ScaleType
        &#34;&#34;&#34;
        decoder_class = self.get_decoder_class(type_string)

        if decoder_class:
            return decoder_class(data=data, **kwargs)

        raise NotImplementedError(&#39;Decoder class for &#34;{}&#34; not found&#39;.format(type_string))

    def clear_type_registry(self):

        if not self.__initial_state:
            self.type_registry = {&#39;types&#39;: {}, &#39;runtime_api&#39;: {}}

            # Class names that contains &#39;&lt;&#39; are excluded because of a side effect that is introduced in
            # get_decoder_class: &#34;Create dynamic class for Part1&lt;Part2&gt; based on Part1 and set class variable Part2 as
            # sub_type&#34; which won&#39;t get reset because class definitions always remain globally

            self.type_registry[&#39;types&#39;].update(
                {
                    cls.__name__.lower(): cls for cls in self.all_subclasses(ScaleDecoder)
                    if &#39;&lt;&#39; not in cls.__name__ and &#39;::&#39; not in cls.__name__
                }
            )

        self.__initial_state = True

    def update_type_registry_types(self, types_dict):
        from scalecodec.types import Enum, Struct, Set, Tuple

        self.__initial_state = False

        for type_string, decoder_class_data in types_dict.items():

            if type(decoder_class_data) == dict:

                # Create dynamic decoder class
                base_cls = None

                if decoder_class_data.get(&#39;base_class&#39;):
                    base_cls = self.get_decoder_class(decoder_class_data[&#39;base_class&#39;])
                    if base_cls is None:
                        raise ValueError(f&#34;Specified base_class &#39;{decoder_class_data[&#39;base_class&#39;]}&#39; for type &#34; +
                                         f&#34;&#39;{type_string}&#39; not found&#34;)

                if decoder_class_data[&#39;type&#39;] == &#39;struct&#39;:

                    if base_cls is None:
                        base_cls = Struct

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                    })

                elif decoder_class_data[&#39;type&#39;] == &#39;tuple&#39;:

                    if base_cls is None:
                        base_cls = Tuple

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                    })

                elif decoder_class_data[&#39;type&#39;] == &#39;enum&#39;:

                    if base_cls is None:
                        base_cls = Enum

                    value_list = decoder_class_data.get(&#39;value_list&#39;)

                    if type(value_list) is dict:
                        # Transform value_list with explicitly specified index numbers
                        value_list = {i: v for v, i in value_list.items()}

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;value_list&#39;: value_list,
                        &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                    })

                elif decoder_class_data[&#39;type&#39;] == &#39;set&#39;:

                    if base_cls is None:
                        base_cls = Set

                    decoder_class = type(type_string, (base_cls,), {
                        &#39;value_list&#39;: decoder_class_data.get(&#39;value_list&#39;),
                        &#39;value_type&#39;: decoder_class_data.get(&#39;value_type&#39;, &#39;u64&#39;)
                    })

                else:
                    raise NotImplementedError(&#34;Dynamic decoding type &#39;{}&#39; not supported&#34;.format(
                        decoder_class_data[&#39;type&#39;])
                    )
            else:
                decoder_class = self.get_decoder_class(decoder_class_data)

            self.type_registry[&#39;types&#39;][type_string.lower()] = decoder_class

    def update_type_registry(self, type_registry):

        # Set runtime ID if set
        self.active_spec_version_id = type_registry.get(&#39;runtime_id&#39;)

        # Set chain ID if set
        self.chain_id = type_registry.get(&#39;chain_id&#39;)

        self.type_registry[&#39;versioning&#39;] = type_registry.get(&#39;versioning&#39;)
        self.type_registry[&#39;runtime_api&#39;].update(type_registry.get(&#39;runtime_api&#39;, {}))
        self.type_registry[&#39;runtime_upgrades&#39;] = type_registry.get(&#39;runtime_upgrades&#39;)

        # Update types
        if &#39;types&#39; in type_registry:
            self.update_type_registry_types(type_registry.get(&#39;types&#39;))

    def set_active_spec_version_id(self, spec_version_id):

        if spec_version_id != self.active_spec_version_id:

            self.active_spec_version_id = spec_version_id

            # Updated type registry with versioned types
            for versioning_item in self.type_registry.get(&#39;versioning&#39;) or []:
                # Check if versioning item is in current version range
                if versioning_item[&#39;runtime_range&#39;][0] &lt;= spec_version_id and \
                        (not versioning_item[&#39;runtime_range&#39;][1] or versioning_item[&#39;runtime_range&#39;][1] &gt;= spec_version_id):
                    # Update types in type registry
                    self.update_type_registry_types(versioning_item[&#39;types&#39;])

    def get_runtime_id_from_upgrades(self, block_number: int) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Retrieve runtime_id for given block_number if runtime_upgrades are specified in the type registry

        Parameters
        ----------
        block_number

        Returns
        -------
        Runtime id
        &#34;&#34;&#34;
        if self.type_registry.get(&#39;runtime_upgrades&#39;):

            if block_number &gt; self.type_registry[&#39;runtime_upgrades&#39;][-1][0]:
                return

            for max_block_number, runtime_id in reversed(self.type_registry[&#39;runtime_upgrades&#39;]):
                if block_number &gt;= max_block_number and runtime_id != -1:
                    return runtime_id

    def set_runtime_upgrades_head(self, block_number: int):
        &#34;&#34;&#34;
        Sets head for given block_number to last runtime_id in runtime_upgrades cache

        Parameters
        ----------
        block_number

        Returns
        -------

        &#34;&#34;&#34;
        if self.type_registry.get(&#39;runtime_upgrades&#39;):
            if self.type_registry[&#39;runtime_upgrades&#39;][-1][1] == -1:
                self.type_registry[&#39;runtime_upgrades&#39;][-1][0] = block_number
            elif block_number &gt; self.type_registry[&#39;runtime_upgrades&#39;][-1][0]:
                self.type_registry[&#39;runtime_upgrades&#39;].append([block_number, -1])

    def get_decoder_class_for_scale_info_definition(
            self, type_string: str, scale_info_type: &#39;GenericRegistryType&#39;, prefix: str
    ):

        decoder_class = None
        base_decoder_class = None

        # Check if base decoder class is defined for path
        if &#39;path&#39; in scale_info_type.value and len(scale_info_type.value[&#39;path&#39;]) &gt; 0:
            path_string = &#39;::&#39;.join(scale_info_type.value[&#34;path&#34;])
            base_decoder_class = self.get_decoder_class(path_string)

            if base_decoder_class is None:

                # Try wildcard type
                catch_all_path = &#39;*::&#39; + &#39;::&#39;.join(scale_info_type.value[&#34;path&#34;][1:])
                base_decoder_class = self.get_decoder_class(catch_all_path)

                if base_decoder_class is None:
                    # Try catch-all type
                    catch_all_path = &#39;*::&#39; * (len(scale_info_type.value[&#39;path&#39;]) - 1) + scale_info_type.value[&#34;path&#34;][-1]
                    base_decoder_class = self.get_decoder_class(catch_all_path)

            if base_decoder_class and hasattr(base_decoder_class, &#39;process_scale_info_definition&#39;):
                # if process_scale_info_definition is implemented result is final
                decoder_class = type(type_string, (base_decoder_class,), {})
                decoder_class.process_scale_info_definition(scale_info_type, prefix)

                # Link ScaleInfo RegistryType to decoder class
                decoder_class.scale_info_type = scale_info_type

                return decoder_class

        if &#34;primitive&#34; in scale_info_type.value[&#34;def&#34;]:
            decoder_class = self.get_decoder_class(scale_info_type.value[&#34;def&#34;][&#34;primitive&#34;])

        elif &#39;array&#39; in scale_info_type.value[&#39;def&#39;]:

            if base_decoder_class is None:
                base_decoder_class = self.get_decoder_class(&#39;FixedLengthArray&#39;)

            decoder_class = type(type_string, (base_decoder_class,), {
                &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;array&#39;][&#39;type&#39;]}&#34;,
                &#39;element_count&#39;: scale_info_type.value[&#39;def&#39;][&#39;array&#39;][&#39;len&#39;]
            })

        elif &#39;composite&#39; in scale_info_type.value[&#39;def&#39;]:

            type_mapping = []

            base_type_string = &#39;Tuple&#39;

            if &#39;fields&#39; in scale_info_type.value[&#39;def&#39;][&#39;composite&#39;]:

                fields = scale_info_type.value[&#39;def&#39;][&#39;composite&#39;][&#39;fields&#39;]

                if all([f.get(&#39;name&#39;) for f in fields]):
                    base_type_string = &#39;Struct&#39;
                    type_mapping = [[field[&#39;name&#39;], f&#34;{prefix}::{field[&#39;type&#39;]}&#34;] for field in fields]

                else:
                    base_type_string = &#39;Tuple&#39;
                    type_mapping = [f&#34;{prefix}::{field[&#39;type&#39;]}&#34; for field in fields]

            if base_decoder_class is None:
                base_decoder_class = self.get_decoder_class(base_type_string)

            decoder_class = type(type_string, (base_decoder_class,), {
                &#39;type_mapping&#39;: type_mapping
            })

        elif &#39;sequence&#39; in scale_info_type.value[&#39;def&#39;]:
            # Vec
            decoder_class = type(type_string, (self.get_decoder_class(&#39;Vec&#39;),), {
                &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;sequence&#39;][&#39;type&#39;]}&#34;
            })

        elif &#39;variant&#39; in scale_info_type.value[&#39;def&#39;]:
            # Enum
            type_mapping = []

            variants = scale_info_type.value[&#39;def&#39;][&#39;variant&#39;][&#39;variants&#39;]

            if len(variants) &gt; 0:
                # Create placeholder list
                variant_length = max([v[&#39;index&#39;] for v in variants]) + 1
                type_mapping = [(None, &#39;Null&#39;)] * variant_length

                for variant in variants:

                    if &#39;fields&#39; in variant:
                        if len(variant[&#39;fields&#39;]) == 0:
                            enum_value = &#39;Null&#39;
                        elif all([f.get(&#39;name&#39;) for f in variant[&#39;fields&#39;]]):
                            # Enum with named fields
                            enum_value = {f.get(&#39;name&#39;): f&#34;{prefix}::{f[&#39;type&#39;]}&#34; for f in variant[&#39;fields&#39;]}
                        else:
                            if len(variant[&#39;fields&#39;]) == 1:
                                enum_value = f&#34;{prefix}::{variant[&#39;fields&#39;][0][&#39;type&#39;]}&#34;
                            else:
                                field_str = &#39;, &#39;.join([f&#34;{prefix}::{f[&#39;type&#39;]}&#34; for f in variant[&#39;fields&#39;]])
                                enum_value = f&#34;({field_str})&#34;
                    else:
                        enum_value = &#39;Null&#39;

                    # Put mapping in right order in list
                    type_mapping[variant[&#39;index&#39;]] = (variant[&#39;name&#39;], enum_value)

            if base_decoder_class is None:
                base_decoder_class = self.get_decoder_class(&#34;Enum&#34;)

            decoder_class = type(type_string, (base_decoder_class,), {
                &#39;type_mapping&#39;: type_mapping
            })

        elif &#39;tuple&#39; in scale_info_type.value[&#39;def&#39;]:

            type_mapping = [f&#34;{prefix}::{f}&#34; for f in scale_info_type.value[&#39;def&#39;][&#39;tuple&#39;]]

            decoder_class = type(type_string, (self.get_decoder_class(&#39;Tuple&#39;),), {
                &#39;type_mapping&#39;: type_mapping
            })

        elif &#39;compact&#39; in scale_info_type.value[&#39;def&#39;]:
            # Compact
            decoder_class = type(type_string, (self.get_decoder_class(&#39;Compact&#39;),), {
                &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;compact&#39;][&#39;type&#39;]}&#34;
            })

        elif &#39;phantom&#39; in scale_info_type.value[&#39;def&#39;]:
            decoder_class = type(type_string, (self.get_decoder_class(&#39;Null&#39;),), {})

        elif &#39;bitsequence&#39; in scale_info_type.value[&#39;def&#39;]:
            decoder_class = type(type_string, (self.get_decoder_class(&#39;BitVec&#39;),), {})

        else:
            raise NotImplementedError(f&#34;RegistryTypeDef {scale_info_type.value[&#39;def&#39;]} not implemented&#34;)

        # if &#39;path&#39; in scale_info_type.value:
        #     decoder_class.type_string = &#39;::&#39;.join(scale_info_type.value[&#39;path&#39;])

        # Link ScaleInfo RegistryType to decoder class

        decoder_class.scale_info_type = scale_info_type

        return decoder_class

    def update_from_scale_info_types(self, scale_info_types: list, prefix: str = None):

        if prefix is None:
            prefix = &#39;scale_info&#39;

        for scale_info_type in scale_info_types:

            idx = scale_info_type[&#39;id&#39;].value

            type_string = f&#34;{prefix}::{idx}&#34;

            decoder_class = self.get_decoder_class_for_scale_info_definition(
                type_string, scale_info_type[&#39;type&#39;], prefix
            )

            if decoder_class is None:
                raise NotImplementedError(f&#34;No decoding class found for scale type {idx}&#34;)

            if decoder_class:
                self.type_registry[&#39;types&#39;][type_string] = decoder_class

                if len(scale_info_type[&#39;type&#39;].value.get(&#39;path&#39;, [])) &gt; 0:
                    path_string = &#39;::&#39;.join(scale_info_type[&#39;type&#39;].value[&#39;path&#39;]).lower()
                    self.type_registry[&#39;types&#39;][path_string] = decoder_class

    def add_portable_registry(self, metadata: &#39;GenericMetadataVersioned&#39;, prefix=None):

        scale_info_types = metadata.portable_registry.value_object[&#39;types&#39;].value_object

        self.update_from_scale_info_types(scale_info_types, prefix=prefix)

        # Todo process extrinsic types
        pass

    def add_contract_metadata_dict_to_type_registry(self, metadata_dict):
        # TODO
        prefix = f&#34;ink::{metadata_dict[&#39;source&#39;][&#39;hash&#39;]}&#34;
        return self.update_from_scale_info_types(metadata_dict[&#39;types&#39;], prefix=prefix)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.base.RuntimeConfiguration" href="#scalecodec.base.RuntimeConfiguration">RuntimeConfiguration</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scalecodec.base.RuntimeConfigurationObject.all_subclasses"><code class="name flex">
<span>def <span class="ident">all_subclasses</span></span>(<span>class_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def all_subclasses(cls, class_):
    return set(class_.__subclasses__()).union(
        [s for c in class_.__subclasses__() for s in cls.all_subclasses(c)])</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.convert_type_string"><code class="name flex">
<span>def <span class="ident">convert_type_string</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def convert_type_string(cls, name):

    name = re.sub(r&#39;T::&#39;, &#34;&#34;, name)
    name = re.sub(r&#39;^T::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;&lt;T&gt;&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;&lt;T as Trait&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;&lt;T as Trait&lt;I&gt;&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;&lt;T as Config&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;&lt;T as Config&lt;I&gt;&gt;::&#39;, &#34;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;\n&#39;, &#34;&#34;, name)
    name = re.sub(r&#39;^(grandpa|session|slashing|limits|beefy_primitives|xcm::opaque)::&#39;, &#34;&#34;, name)
    name = re.sub(r&#39;VecDeque&lt;&#39;, &#34;Vec&lt;&#34;, name, flags=re.IGNORECASE)
    name = re.sub(r&#39;^Box&lt;(.+)&gt;$&#39;, r&#39;\1&#39;, name, flags=re.IGNORECASE)

    if name == &#39;()&#39;:
        return &#34;Null&#34;
    if name.lower() in [&#39;vec&lt;u8&gt;&#39;, &#39;&amp;[u8]&#39;, &#34;&amp; &#39;static[u8]&#34;]:
        return &#34;Bytes&#34;
    if name.lower() == &#39;&lt;lookup as staticlookup&gt;::source&#39;:
        return &#39;LookupSource&#39;
    if name.lower() == &#39;&lt;balance as hascompact&gt;::type&#39;:
        return &#39;Compact&lt;Balance&gt;&#39;
    if name.lower() == &#39;&lt;blocknumber as hascompact&gt;::type&#39;:
        return &#39;Compact&lt;BlockNumber&gt;&#39;
    if name.lower() == &#39;&lt;moment as hascompact&gt;::type&#39;:
        return &#39;Compact&lt;Moment&gt;&#39;
    if name.lower() == &#39;&lt;inherentofflinereport as inherentofflinereport&gt;::inherent&#39;:
        return &#39;InherentOfflineReport&#39;

    return name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.base.RuntimeConfigurationObject.add_contract_metadata_dict_to_type_registry"><code class="name flex">
<span>def <span class="ident">add_contract_metadata_dict_to_type_registry</span></span>(<span>self, metadata_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_contract_metadata_dict_to_type_registry(self, metadata_dict):
    # TODO
    prefix = f&#34;ink::{metadata_dict[&#39;source&#39;][&#39;hash&#39;]}&#34;
    return self.update_from_scale_info_types(metadata_dict[&#39;types&#39;], prefix=prefix)</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.add_portable_registry"><code class="name flex">
<span>def <span class="ident">add_portable_registry</span></span>(<span>self, metadata: GenericMetadataVersioned, prefix=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_portable_registry(self, metadata: &#39;GenericMetadataVersioned&#39;, prefix=None):

    scale_info_types = metadata.portable_registry.value_object[&#39;types&#39;].value_object

    self.update_from_scale_info_types(scale_info_types, prefix=prefix)

    # Todo process extrinsic types
    pass</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.clear_type_registry"><code class="name flex">
<span>def <span class="ident">clear_type_registry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_type_registry(self):

    if not self.__initial_state:
        self.type_registry = {&#39;types&#39;: {}, &#39;runtime_api&#39;: {}}

        # Class names that contains &#39;&lt;&#39; are excluded because of a side effect that is introduced in
        # get_decoder_class: &#34;Create dynamic class for Part1&lt;Part2&gt; based on Part1 and set class variable Part2 as
        # sub_type&#34; which won&#39;t get reset because class definitions always remain globally

        self.type_registry[&#39;types&#39;].update(
            {
                cls.__name__.lower(): cls for cls in self.all_subclasses(ScaleDecoder)
                if &#39;&lt;&#39; not in cls.__name__ and &#39;::&#39; not in cls.__name__
            }
        )

    self.__initial_state = True</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.create_scale_object"><code class="name flex">
<span>def <span class="ident">create_scale_object</span></span>(<span>self, type_string: str, data: Optional[ForwardRef('<a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a>')] = None, **kwargs) ‑> <a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <code><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></code> object with given type_string, for example 'u32', 'Bytes' or 'scale_info::2'
(scale_info:: prefixed types are defined in the <code>PortableRegistry</code> object of the runtime metadata.)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_string</code></strong> :&ensp;<code>string representation</code> of <code>a </code>ScaleType``</dt>
<dd>&nbsp;</dd>
<dt><strong><code>data</code></strong> :&ensp;<code><a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a> data to decode</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_scale_object(self, type_string: str, data: Optional[&#39;ScaleBytes&#39;] = None, **kwargs) -&gt; &#39;ScaleType&#39;:
    &#34;&#34;&#34;
    Creates a new `ScaleType` object with given type_string, for example &#39;u32&#39;, &#39;Bytes&#39; or &#39;scale_info::2&#39;
    (scale_info:: prefixed types are defined in the `PortableRegistry` object of the runtime metadata.)

    Parameters
    ----------
    type_string: string representation of a `ScaleType`
    data: ScaleBytes data to decode
    kwargs

    Returns
    -------
    ScaleType
    &#34;&#34;&#34;
    decoder_class = self.get_decoder_class(type_string)

    if decoder_class:
        return decoder_class(data=data, **kwargs)

    raise NotImplementedError(&#39;Decoder class for &#34;{}&#34; not found&#39;.format(type_string))</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.get_decoder_class"><code class="name flex">
<span>def <span class="ident">get_decoder_class</span></span>(<span>self, type_string: Union[str, dict])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decoder_class(self, type_string: Union[str, dict]):

    if type(type_string) is dict:
        # Inner struct
        decoder_class = type(&#39;InnerStruct&#39;, (self.get_decoder_class(&#39;Struct&#39;),), {
            &#39;type_mapping&#39;: tuple(type_string.items())
        })
        decoder_class.runtime_config = self
        return decoder_class

    if type_string.strip() == &#39;&#39;:
        return None

    if self.implements_scale_info is False:
        type_string = self.convert_type_string(type_string)

    decoder_class = self.type_registry.get(&#39;types&#39;, {}).get(type_string.lower(), None)

    if not decoder_class:

        # Type string containg subtype
        if type_string[-1:] == &#39;&gt;&#39;:

            # Extract sub types
            type_parts = re.match(r&#39;^([^&lt;]*)&lt;(.+)&gt;$&#39;, type_string)

            if type_parts:
                type_parts = type_parts.groups()

            if type_parts:
                # Create dynamic class for Part1&lt;Part2&gt; based on Part1 and set class variable Part2 as sub_type
                base_class = self.type_registry.get(&#39;types&#39;, {}).get(type_parts[0].lower(), None)
                if base_class:
                    decoder_class = type(type_string, (base_class,), {&#39;sub_type&#39;: type_parts[1]})

        # Custom tuples
        elif type_string != &#39;()&#39; and type_string[0] == &#39;(&#39; and type_string[-1] == &#39;)&#39;:

            decoder_class = type(type_string, (self.get_decoder_class(&#39;tuple&#39;),), {
                &#39;type_string&#39;: type_string
            })

            decoder_class.build_type_mapping()

        elif type_string[0] == &#39;[&#39; and type_string[-1] == &#39;]&#39;:
            type_parts = re.match(r&#39;^\[([A-Za-z0-9]+); ([0-9]+)\]$&#39;, type_string)

            if type_parts:
                type_parts = type_parts.groups()

            if type_parts:
                # Create dynamic class for e.g. [u8; 4] resulting in array of u8 with 4 elements
                decoder_class = type(type_string, (self.get_decoder_class(&#39;FixedLengthArray&#39;),), {
                    &#39;sub_type&#39;: type_parts[0],
                    &#39;element_count&#39;: int(type_parts[1])
                })

    if decoder_class:
        # Attach RuntimeConfigurationObject to new class
        decoder_class.runtime_config = self

    return decoder_class</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.get_decoder_class_for_scale_info_definition"><code class="name flex">
<span>def <span class="ident">get_decoder_class_for_scale_info_definition</span></span>(<span>self, type_string: str, scale_info_type: GenericRegistryType, prefix: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decoder_class_for_scale_info_definition(
        self, type_string: str, scale_info_type: &#39;GenericRegistryType&#39;, prefix: str
):

    decoder_class = None
    base_decoder_class = None

    # Check if base decoder class is defined for path
    if &#39;path&#39; in scale_info_type.value and len(scale_info_type.value[&#39;path&#39;]) &gt; 0:
        path_string = &#39;::&#39;.join(scale_info_type.value[&#34;path&#34;])
        base_decoder_class = self.get_decoder_class(path_string)

        if base_decoder_class is None:

            # Try wildcard type
            catch_all_path = &#39;*::&#39; + &#39;::&#39;.join(scale_info_type.value[&#34;path&#34;][1:])
            base_decoder_class = self.get_decoder_class(catch_all_path)

            if base_decoder_class is None:
                # Try catch-all type
                catch_all_path = &#39;*::&#39; * (len(scale_info_type.value[&#39;path&#39;]) - 1) + scale_info_type.value[&#34;path&#34;][-1]
                base_decoder_class = self.get_decoder_class(catch_all_path)

        if base_decoder_class and hasattr(base_decoder_class, &#39;process_scale_info_definition&#39;):
            # if process_scale_info_definition is implemented result is final
            decoder_class = type(type_string, (base_decoder_class,), {})
            decoder_class.process_scale_info_definition(scale_info_type, prefix)

            # Link ScaleInfo RegistryType to decoder class
            decoder_class.scale_info_type = scale_info_type

            return decoder_class

    if &#34;primitive&#34; in scale_info_type.value[&#34;def&#34;]:
        decoder_class = self.get_decoder_class(scale_info_type.value[&#34;def&#34;][&#34;primitive&#34;])

    elif &#39;array&#39; in scale_info_type.value[&#39;def&#39;]:

        if base_decoder_class is None:
            base_decoder_class = self.get_decoder_class(&#39;FixedLengthArray&#39;)

        decoder_class = type(type_string, (base_decoder_class,), {
            &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;array&#39;][&#39;type&#39;]}&#34;,
            &#39;element_count&#39;: scale_info_type.value[&#39;def&#39;][&#39;array&#39;][&#39;len&#39;]
        })

    elif &#39;composite&#39; in scale_info_type.value[&#39;def&#39;]:

        type_mapping = []

        base_type_string = &#39;Tuple&#39;

        if &#39;fields&#39; in scale_info_type.value[&#39;def&#39;][&#39;composite&#39;]:

            fields = scale_info_type.value[&#39;def&#39;][&#39;composite&#39;][&#39;fields&#39;]

            if all([f.get(&#39;name&#39;) for f in fields]):
                base_type_string = &#39;Struct&#39;
                type_mapping = [[field[&#39;name&#39;], f&#34;{prefix}::{field[&#39;type&#39;]}&#34;] for field in fields]

            else:
                base_type_string = &#39;Tuple&#39;
                type_mapping = [f&#34;{prefix}::{field[&#39;type&#39;]}&#34; for field in fields]

        if base_decoder_class is None:
            base_decoder_class = self.get_decoder_class(base_type_string)

        decoder_class = type(type_string, (base_decoder_class,), {
            &#39;type_mapping&#39;: type_mapping
        })

    elif &#39;sequence&#39; in scale_info_type.value[&#39;def&#39;]:
        # Vec
        decoder_class = type(type_string, (self.get_decoder_class(&#39;Vec&#39;),), {
            &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;sequence&#39;][&#39;type&#39;]}&#34;
        })

    elif &#39;variant&#39; in scale_info_type.value[&#39;def&#39;]:
        # Enum
        type_mapping = []

        variants = scale_info_type.value[&#39;def&#39;][&#39;variant&#39;][&#39;variants&#39;]

        if len(variants) &gt; 0:
            # Create placeholder list
            variant_length = max([v[&#39;index&#39;] for v in variants]) + 1
            type_mapping = [(None, &#39;Null&#39;)] * variant_length

            for variant in variants:

                if &#39;fields&#39; in variant:
                    if len(variant[&#39;fields&#39;]) == 0:
                        enum_value = &#39;Null&#39;
                    elif all([f.get(&#39;name&#39;) for f in variant[&#39;fields&#39;]]):
                        # Enum with named fields
                        enum_value = {f.get(&#39;name&#39;): f&#34;{prefix}::{f[&#39;type&#39;]}&#34; for f in variant[&#39;fields&#39;]}
                    else:
                        if len(variant[&#39;fields&#39;]) == 1:
                            enum_value = f&#34;{prefix}::{variant[&#39;fields&#39;][0][&#39;type&#39;]}&#34;
                        else:
                            field_str = &#39;, &#39;.join([f&#34;{prefix}::{f[&#39;type&#39;]}&#34; for f in variant[&#39;fields&#39;]])
                            enum_value = f&#34;({field_str})&#34;
                else:
                    enum_value = &#39;Null&#39;

                # Put mapping in right order in list
                type_mapping[variant[&#39;index&#39;]] = (variant[&#39;name&#39;], enum_value)

        if base_decoder_class is None:
            base_decoder_class = self.get_decoder_class(&#34;Enum&#34;)

        decoder_class = type(type_string, (base_decoder_class,), {
            &#39;type_mapping&#39;: type_mapping
        })

    elif &#39;tuple&#39; in scale_info_type.value[&#39;def&#39;]:

        type_mapping = [f&#34;{prefix}::{f}&#34; for f in scale_info_type.value[&#39;def&#39;][&#39;tuple&#39;]]

        decoder_class = type(type_string, (self.get_decoder_class(&#39;Tuple&#39;),), {
            &#39;type_mapping&#39;: type_mapping
        })

    elif &#39;compact&#39; in scale_info_type.value[&#39;def&#39;]:
        # Compact
        decoder_class = type(type_string, (self.get_decoder_class(&#39;Compact&#39;),), {
            &#39;sub_type&#39;: f&#34;{prefix}::{scale_info_type.value[&#39;def&#39;][&#39;compact&#39;][&#39;type&#39;]}&#34;
        })

    elif &#39;phantom&#39; in scale_info_type.value[&#39;def&#39;]:
        decoder_class = type(type_string, (self.get_decoder_class(&#39;Null&#39;),), {})

    elif &#39;bitsequence&#39; in scale_info_type.value[&#39;def&#39;]:
        decoder_class = type(type_string, (self.get_decoder_class(&#39;BitVec&#39;),), {})

    else:
        raise NotImplementedError(f&#34;RegistryTypeDef {scale_info_type.value[&#39;def&#39;]} not implemented&#34;)

    # if &#39;path&#39; in scale_info_type.value:
    #     decoder_class.type_string = &#39;::&#39;.join(scale_info_type.value[&#39;path&#39;])

    # Link ScaleInfo RegistryType to decoder class

    decoder_class.scale_info_type = scale_info_type

    return decoder_class</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.get_runtime_id_from_upgrades"><code class="name flex">
<span>def <span class="ident">get_runtime_id_from_upgrades</span></span>(<span>self, block_number: int) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve runtime_id for given block_number if runtime_upgrades are specified in the type registry</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_number</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Runtime id</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runtime_id_from_upgrades(self, block_number: int) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Retrieve runtime_id for given block_number if runtime_upgrades are specified in the type registry

    Parameters
    ----------
    block_number

    Returns
    -------
    Runtime id
    &#34;&#34;&#34;
    if self.type_registry.get(&#39;runtime_upgrades&#39;):

        if block_number &gt; self.type_registry[&#39;runtime_upgrades&#39;][-1][0]:
            return

        for max_block_number, runtime_id in reversed(self.type_registry[&#39;runtime_upgrades&#39;]):
            if block_number &gt;= max_block_number and runtime_id != -1:
                return runtime_id</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.set_active_spec_version_id"><code class="name flex">
<span>def <span class="ident">set_active_spec_version_id</span></span>(<span>self, spec_version_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_active_spec_version_id(self, spec_version_id):

    if spec_version_id != self.active_spec_version_id:

        self.active_spec_version_id = spec_version_id

        # Updated type registry with versioned types
        for versioning_item in self.type_registry.get(&#39;versioning&#39;) or []:
            # Check if versioning item is in current version range
            if versioning_item[&#39;runtime_range&#39;][0] &lt;= spec_version_id and \
                    (not versioning_item[&#39;runtime_range&#39;][1] or versioning_item[&#39;runtime_range&#39;][1] &gt;= spec_version_id):
                # Update types in type registry
                self.update_type_registry_types(versioning_item[&#39;types&#39;])</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.set_runtime_upgrades_head"><code class="name flex">
<span>def <span class="ident">set_runtime_upgrades_head</span></span>(<span>self, block_number: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets head for given block_number to last runtime_id in runtime_upgrades cache</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_number</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_runtime_upgrades_head(self, block_number: int):
    &#34;&#34;&#34;
    Sets head for given block_number to last runtime_id in runtime_upgrades cache

    Parameters
    ----------
    block_number

    Returns
    -------

    &#34;&#34;&#34;
    if self.type_registry.get(&#39;runtime_upgrades&#39;):
        if self.type_registry[&#39;runtime_upgrades&#39;][-1][1] == -1:
            self.type_registry[&#39;runtime_upgrades&#39;][-1][0] = block_number
        elif block_number &gt; self.type_registry[&#39;runtime_upgrades&#39;][-1][0]:
            self.type_registry[&#39;runtime_upgrades&#39;].append([block_number, -1])</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.update_from_scale_info_types"><code class="name flex">
<span>def <span class="ident">update_from_scale_info_types</span></span>(<span>self, scale_info_types: list, prefix: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_from_scale_info_types(self, scale_info_types: list, prefix: str = None):

    if prefix is None:
        prefix = &#39;scale_info&#39;

    for scale_info_type in scale_info_types:

        idx = scale_info_type[&#39;id&#39;].value

        type_string = f&#34;{prefix}::{idx}&#34;

        decoder_class = self.get_decoder_class_for_scale_info_definition(
            type_string, scale_info_type[&#39;type&#39;], prefix
        )

        if decoder_class is None:
            raise NotImplementedError(f&#34;No decoding class found for scale type {idx}&#34;)

        if decoder_class:
            self.type_registry[&#39;types&#39;][type_string] = decoder_class

            if len(scale_info_type[&#39;type&#39;].value.get(&#39;path&#39;, [])) &gt; 0:
                path_string = &#39;::&#39;.join(scale_info_type[&#39;type&#39;].value[&#39;path&#39;]).lower()
                self.type_registry[&#39;types&#39;][path_string] = decoder_class</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.update_type_registry"><code class="name flex">
<span>def <span class="ident">update_type_registry</span></span>(<span>self, type_registry)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_type_registry(self, type_registry):

    # Set runtime ID if set
    self.active_spec_version_id = type_registry.get(&#39;runtime_id&#39;)

    # Set chain ID if set
    self.chain_id = type_registry.get(&#39;chain_id&#39;)

    self.type_registry[&#39;versioning&#39;] = type_registry.get(&#39;versioning&#39;)
    self.type_registry[&#39;runtime_api&#39;].update(type_registry.get(&#39;runtime_api&#39;, {}))
    self.type_registry[&#39;runtime_upgrades&#39;] = type_registry.get(&#39;runtime_upgrades&#39;)

    # Update types
    if &#39;types&#39; in type_registry:
        self.update_type_registry_types(type_registry.get(&#39;types&#39;))</code></pre>
</details>
</dd>
<dt id="scalecodec.base.RuntimeConfigurationObject.update_type_registry_types"><code class="name flex">
<span>def <span class="ident">update_type_registry_types</span></span>(<span>self, types_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_type_registry_types(self, types_dict):
    from scalecodec.types import Enum, Struct, Set, Tuple

    self.__initial_state = False

    for type_string, decoder_class_data in types_dict.items():

        if type(decoder_class_data) == dict:

            # Create dynamic decoder class
            base_cls = None

            if decoder_class_data.get(&#39;base_class&#39;):
                base_cls = self.get_decoder_class(decoder_class_data[&#39;base_class&#39;])
                if base_cls is None:
                    raise ValueError(f&#34;Specified base_class &#39;{decoder_class_data[&#39;base_class&#39;]}&#39; for type &#34; +
                                     f&#34;&#39;{type_string}&#39; not found&#34;)

            if decoder_class_data[&#39;type&#39;] == &#39;struct&#39;:

                if base_cls is None:
                    base_cls = Struct

                decoder_class = type(type_string, (base_cls,), {
                    &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                })

            elif decoder_class_data[&#39;type&#39;] == &#39;tuple&#39;:

                if base_cls is None:
                    base_cls = Tuple

                decoder_class = type(type_string, (base_cls,), {
                    &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                })

            elif decoder_class_data[&#39;type&#39;] == &#39;enum&#39;:

                if base_cls is None:
                    base_cls = Enum

                value_list = decoder_class_data.get(&#39;value_list&#39;)

                if type(value_list) is dict:
                    # Transform value_list with explicitly specified index numbers
                    value_list = {i: v for v, i in value_list.items()}

                decoder_class = type(type_string, (base_cls,), {
                    &#39;value_list&#39;: value_list,
                    &#39;type_mapping&#39;: decoder_class_data.get(&#39;type_mapping&#39;)
                })

            elif decoder_class_data[&#39;type&#39;] == &#39;set&#39;:

                if base_cls is None:
                    base_cls = Set

                decoder_class = type(type_string, (base_cls,), {
                    &#39;value_list&#39;: decoder_class_data.get(&#39;value_list&#39;),
                    &#39;value_type&#39;: decoder_class_data.get(&#39;value_type&#39;, &#39;u64&#39;)
                })

            else:
                raise NotImplementedError(&#34;Dynamic decoding type &#39;{}&#39; not supported&#34;.format(
                    decoder_class_data[&#39;type&#39;])
                )
        else:
            decoder_class = self.get_decoder_class(decoder_class_data)

        self.type_registry[&#39;types&#39;][type_string.lower()] = decoder_class</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scalecodec.base.ScaleBytes"><code class="flex name class">
<span>class <span class="ident">ScaleBytes</span></span>
<span>(</span><span>data: Union[str, bytes, bytearray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScaleBytes:

    def __init__(self, data: Union[str, bytes, bytearray]):
        self.offset = 0

        if type(data) is bytearray:
            self.data = data
        elif type(data) is bytes:
            self.data = bytearray(data)
        elif type(data) is str and data[0:2] == &#39;0x&#39;:
            self.data = bytearray.fromhex(data[2:])
        else:
            raise ValueError(&#34;Provided data is not in supported format: provided &#39;{}&#39;&#34;.format(type(data)))

        self.length = len(self.data)

    def get_next_bytes(self, length: int) -&gt; bytearray:
        data = self.data[self.offset:self.offset + length]
        self.offset += length
        return data

    def get_remaining_bytes(self) -&gt; bytearray:
        data = self.data[self.offset:]
        self.offset = self.length
        return data

    def get_remaining_length(self) -&gt; int:
        return self.length - self.offset

    def reset(self):
        self.offset = 0

    def __str__(self):
        return &#34;0x{}&#34;.format(self.data.hex())

    def __eq__(self, other):
        if not hasattr(other, &#39;data&#39;):
            return False
        return self.data == other.data

    def __len__(self):
        return len(self.data)

    def __repr__(self):
        return &#34;&lt;{}(data=0x{})&gt;&#34;.format(self.__class__.__name__, self.data.hex())

    def __add__(self, data):

        if type(data) == ScaleBytes:
            return ScaleBytes(self.data + data.data)

        if type(data) == bytes:
            data = bytearray(data)
        elif type(data) == str and data[0:2] == &#39;0x&#39;:
            data = bytearray.fromhex(data[2:])

        if type(data) == bytearray:
            return ScaleBytes(self.data + data)

    def to_hex(self) -&gt; str:
        return f&#39;0x{self.data.hex()}&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.base.ScaleBytes.get_next_bytes"><code class="name flex">
<span>def <span class="ident">get_next_bytes</span></span>(<span>self, length: int) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_bytes(self, length: int) -&gt; bytearray:
    data = self.data[self.offset:self.offset + length]
    self.offset += length
    return data</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleBytes.get_remaining_bytes"><code class="name flex">
<span>def <span class="ident">get_remaining_bytes</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_remaining_bytes(self) -&gt; bytearray:
    data = self.data[self.offset:]
    self.offset = self.length
    return data</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleBytes.get_remaining_length"><code class="name flex">
<span>def <span class="ident">get_remaining_length</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_remaining_length(self) -&gt; int:
    return self.length - self.offset</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleBytes.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.offset = 0</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleBytes.to_hex"><code class="name flex">
<span>def <span class="ident">to_hex</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_hex(self) -&gt; str:
    return f&#39;0x{self.data.hex()}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scalecodec.base.ScaleDecoder"><code class="flex name class">
<span>class <span class="ident">ScaleDecoder</span></span>
<span>(</span><span>data: <a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a>, sub_type: str = None, runtime_config: <a title="scalecodec.base.RuntimeConfigurationObject" href="#scalecodec.base.RuntimeConfigurationObject">RuntimeConfigurationObject</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScaleDecoder(ABC):

    type_string = None

    type_mapping = None

    sub_type = None

    runtime_config = None

    def __init__(self, data: ScaleBytes, sub_type: str = None, runtime_config: RuntimeConfigurationObject = None):

        if sub_type:
            self.sub_type = sub_type

        if self.type_mapping is None and self.type_string:
            self.build_type_mapping()

        if data:
            assert(type(data) == ScaleBytes)

        if runtime_config:
            self.runtime_config = runtime_config

        if not self.runtime_config:
            # if no runtime config is provided, fallback on singleton
            self.runtime_config = RuntimeConfiguration()

        self.data = data

        self.value_object = None
        self.value_serialized = None

        self.decoded = False

        self.data_start_offset = None
        self.data_end_offset = None

    @property
    def value(self):
        # TODO fix
        # if not self.decoded:
        #     self.decode()
        return self.value_serialized

    @value.setter
    def value(self, value):
        self.value_serialized = value

    @staticmethod
    def is_primitive(type_string: str) -&gt; bool:
        return type_string in (&#39;bool&#39;, &#39;u8&#39;, &#39;u16&#39;, &#39;u32&#39;, &#39;u64&#39;, &#39;u128&#39;, &#39;u256&#39;, &#39;i8&#39;, &#39;i16&#39;, &#39;i32&#39;, &#39;i64&#39;, &#39;i128&#39;,
                               &#39;i256&#39;, &#39;h160&#39;, &#39;h256&#39;, &#39;h512&#39;, &#39;[u8; 4]&#39;, &#39;[u8; 4]&#39;, &#39;[u8; 8]&#39;, &#39;[u8; 16]&#39;, &#39;[u8; 32]&#39;,
                               &#39;&amp;[u8]&#39;)

    @classmethod
    def build_type_mapping(cls):

        if cls.type_string and cls.type_string[0] == &#39;(&#39; and cls.type_string[-1] == &#39;)&#39;:
            type_mapping = ()

            tuple_contents = cls.type_string[1:-1]

            # replace subtype types
            sub_types = re.search(r&#39;([A-Za-z]+[&lt;][^&gt;]*[&gt;])&#39;, tuple_contents)
            if sub_types:
                sub_types = sub_types.groups()
                for sub_type in sub_types:
                    tuple_contents = tuple_contents.replace(sub_type, sub_type.replace(&#39;,&#39;, &#39;|&#39;))

            for tuple_element in tuple_contents.split(&#39;,&#39;):
                type_mapping += (tuple_element.strip().replace(&#39;|&#39;, &#39;,&#39;),)

            cls.type_mapping = type_mapping

    def get_next_bytes(self, length) -&gt; bytearray:
        data = self.data.get_next_bytes(length)
        return data

    def get_next_u8(self) -&gt; int:
        return int.from_bytes(self.get_next_bytes(1), byteorder=&#39;little&#39;)

    def get_next_bool(self) -&gt; bool:
        data = self.get_next_bytes(1)
        if data not in [b&#39;\x00&#39;, b&#39;\x01&#39;]:
            raise InvalidScaleTypeValueException(&#39;Invalid value for datatype &#34;bool&#34;&#39;)
        return data == b&#39;\x01&#39;

    def get_remaining_bytes(self) -&gt; bytearray:
        data = self.data.get_remaining_bytes()
        return data

    def get_used_bytes(self) -&gt; bytearray:
        return self.data.data[self.data_start_offset:self.data_end_offset]

    @abstractmethod
    def process(self):
        raise NotImplementedError

    def decode(self, data: ScaleBytes = None, check_remaining=True):

        if data is not None:
            self.decoded = False
            self.data = data

        if not self.decoded:

            self.data_start_offset = self.data.offset
            self.value_serialized = self.process()
            self.decoded = True

            if self.value_object is None:
                # Default for value_object if not explicitly defined
                self.value_object = self.value_serialized

            self.data_end_offset = self.data.offset

            if check_remaining and self.data.offset != self.data.length:
                raise RemainingScaleBytesNotEmptyException(
                    f&#39;Decoding &lt;{self.__class__.__name__}&gt; - Current offset: {self.data.offset} / length: {self.data.length}&#39;
                )

            if self.data.offset &gt; self.data.length:
                raise RemainingScaleBytesNotEmptyException(
                    f&#39;Decoding &lt;{self.__class__.__name__}&gt; - No more bytes available (needed: {self.data.offset} / total: {self.data.length})&#39;
                )

        return self.value

    def __str__(self):
        return str(self.serialize()) or &#39;&#39;

    def __repr__(self):
        return &#34;&lt;{}(value={})&gt;&#34;.format(self.__class__.__name__, self.serialize())

    def encode(self, value=None):

        if value and issubclass(self.__class__, value.__class__):
            # Accept instance of current class directly
            self.data = value.data
            self.value_object = value.value_object
            self.value_serialized = value.value_serialized
            return value.data

        if value is not None:
            self.value_serialized = value
            self.decoded = True

        self.data = self.process_encode(self.value_serialized)

        if self.value_object is None:
            self.value_object = self.value_serialized

        return self.data

    def process_encode(self, value) -&gt; ScaleBytes:
        raise NotImplementedError(&#34;Encoding not implemented for this ScaleType&#34;)

    @classmethod
    def get_decoder_class(cls, type_string, data=None, runtime_config=None, **kwargs):
        &#34;&#34;&#34;

        Parameters
        ----------
        type_string
        data
        runtime_config
        kwargs

        Returns
        -------
        ScaleType
        &#34;&#34;&#34;

        warnings.warn(&#34;Use RuntimeConfigurationObject.create_scale_object() instead&#34;, DeprecationWarning)

        if not runtime_config:
            runtime_config = RuntimeConfiguration()

        decoder_class = runtime_config.get_decoder_class(
            type_string
        )
        if decoder_class:
            return decoder_class(data=data, runtime_config=runtime_config, **kwargs)

        raise NotImplementedError(&#39;Decoder class for &#34;{}&#34; not found&#39;.format(type_string))

    # TODO rename to decode_type (confusing when encoding is introduced)
    def process_type(self, type_string, **kwargs):
        obj = self.runtime_config.create_scale_object(type_string, self.data, **kwargs)
        obj.decode(check_remaining=False)
        return obj

    def serialize(self):
        return self.value_serialized

    @classmethod
    def convert_type(cls, name):
        return RuntimeConfigurationObject.convert_type_string(name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.base.ScaleDecoder.runtime_config"><code class="name">var <span class="ident">runtime_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.base.ScaleDecoder.sub_type"><code class="name">var <span class="ident">sub_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.base.ScaleDecoder.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.base.ScaleDecoder.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scalecodec.base.ScaleDecoder.build_type_mapping"><code class="name flex">
<span>def <span class="ident">build_type_mapping</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_type_mapping(cls):

    if cls.type_string and cls.type_string[0] == &#39;(&#39; and cls.type_string[-1] == &#39;)&#39;:
        type_mapping = ()

        tuple_contents = cls.type_string[1:-1]

        # replace subtype types
        sub_types = re.search(r&#39;([A-Za-z]+[&lt;][^&gt;]*[&gt;])&#39;, tuple_contents)
        if sub_types:
            sub_types = sub_types.groups()
            for sub_type in sub_types:
                tuple_contents = tuple_contents.replace(sub_type, sub_type.replace(&#39;,&#39;, &#39;|&#39;))

        for tuple_element in tuple_contents.split(&#39;,&#39;):
            type_mapping += (tuple_element.strip().replace(&#39;|&#39;, &#39;,&#39;),)

        cls.type_mapping = type_mapping</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.convert_type"><code class="name flex">
<span>def <span class="ident">convert_type</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def convert_type(cls, name):
    return RuntimeConfigurationObject.convert_type_string(name)</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.get_decoder_class"><code class="name flex">
<span>def <span class="ident">get_decoder_class</span></span>(<span>type_string, data=None, runtime_config=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_string</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_decoder_class(cls, type_string, data=None, runtime_config=None, **kwargs):
    &#34;&#34;&#34;

    Parameters
    ----------
    type_string
    data
    runtime_config
    kwargs

    Returns
    -------
    ScaleType
    &#34;&#34;&#34;

    warnings.warn(&#34;Use RuntimeConfigurationObject.create_scale_object() instead&#34;, DeprecationWarning)

    if not runtime_config:
        runtime_config = RuntimeConfiguration()

    decoder_class = runtime_config.get_decoder_class(
        type_string
    )
    if decoder_class:
        return decoder_class(data=data, runtime_config=runtime_config, **kwargs)

    raise NotImplementedError(&#39;Decoder class for &#34;{}&#34; not found&#39;.format(type_string))</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.is_primitive"><code class="name flex">
<span>def <span class="ident">is_primitive</span></span>(<span>type_string: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_primitive(type_string: str) -&gt; bool:
    return type_string in (&#39;bool&#39;, &#39;u8&#39;, &#39;u16&#39;, &#39;u32&#39;, &#39;u64&#39;, &#39;u128&#39;, &#39;u256&#39;, &#39;i8&#39;, &#39;i16&#39;, &#39;i32&#39;, &#39;i64&#39;, &#39;i128&#39;,
                           &#39;i256&#39;, &#39;h160&#39;, &#39;h256&#39;, &#39;h512&#39;, &#39;[u8; 4]&#39;, &#39;[u8; 4]&#39;, &#39;[u8; 8]&#39;, &#39;[u8; 16]&#39;, &#39;[u8; 32]&#39;,
                           &#39;&amp;[u8]&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="scalecodec.base.ScaleDecoder.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    # TODO fix
    # if not self.decoded:
    #     self.decode()
    return self.value_serialized</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.base.ScaleDecoder.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, data: <a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a> = None, check_remaining=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, data: ScaleBytes = None, check_remaining=True):

    if data is not None:
        self.decoded = False
        self.data = data

    if not self.decoded:

        self.data_start_offset = self.data.offset
        self.value_serialized = self.process()
        self.decoded = True

        if self.value_object is None:
            # Default for value_object if not explicitly defined
            self.value_object = self.value_serialized

        self.data_end_offset = self.data.offset

        if check_remaining and self.data.offset != self.data.length:
            raise RemainingScaleBytesNotEmptyException(
                f&#39;Decoding &lt;{self.__class__.__name__}&gt; - Current offset: {self.data.offset} / length: {self.data.length}&#39;
            )

        if self.data.offset &gt; self.data.length:
            raise RemainingScaleBytesNotEmptyException(
                f&#39;Decoding &lt;{self.__class__.__name__}&gt; - No more bytes available (needed: {self.data.offset} / total: {self.data.length})&#39;
            )

    return self.value</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, value=None):

    if value and issubclass(self.__class__, value.__class__):
        # Accept instance of current class directly
        self.data = value.data
        self.value_object = value.value_object
        self.value_serialized = value.value_serialized
        return value.data

    if value is not None:
        self.value_serialized = value
        self.decoded = True

    self.data = self.process_encode(self.value_serialized)

    if self.value_object is None:
        self.value_object = self.value_serialized

    return self.data</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.get_next_bool"><code class="name flex">
<span>def <span class="ident">get_next_bool</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_bool(self) -&gt; bool:
    data = self.get_next_bytes(1)
    if data not in [b&#39;\x00&#39;, b&#39;\x01&#39;]:
        raise InvalidScaleTypeValueException(&#39;Invalid value for datatype &#34;bool&#34;&#39;)
    return data == b&#39;\x01&#39;</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.get_next_bytes"><code class="name flex">
<span>def <span class="ident">get_next_bytes</span></span>(<span>self, length) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_bytes(self, length) -&gt; bytearray:
    data = self.data.get_next_bytes(length)
    return data</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.get_next_u8"><code class="name flex">
<span>def <span class="ident">get_next_u8</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_u8(self) -&gt; int:
    return int.from_bytes(self.get_next_bytes(1), byteorder=&#39;little&#39;)</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.get_remaining_bytes"><code class="name flex">
<span>def <span class="ident">get_remaining_bytes</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_remaining_bytes(self) -&gt; bytearray:
    data = self.data.get_remaining_bytes()
    return data</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.get_used_bytes"><code class="name flex">
<span>def <span class="ident">get_used_bytes</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_used_bytes(self) -&gt; bytearray:
    return self.data.data[self.data_start_offset:self.data_end_offset]</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def process(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value) ‑> <a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value) -&gt; ScaleBytes:
    raise NotImplementedError(&#34;Encoding not implemented for this ScaleType&#34;)</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.process_type"><code class="name flex">
<span>def <span class="ident">process_type</span></span>(<span>self, type_string, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_type(self, type_string, **kwargs):
    obj = self.runtime_config.create_scale_object(type_string, self.data, **kwargs)
    obj.decode(check_remaining=False)
    return obj</code></pre>
</details>
</dd>
<dt id="scalecodec.base.ScaleDecoder.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self):
    return self.value_serialized</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scalecodec.base.ScalePrimitive"><code class="flex name class">
<span>class <span class="ident">ScalePrimitive</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None, runtime_config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code><a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>VersionedMetadata</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code><a title="scalecodec.base.RuntimeConfigurationObject" href="#scalecodec.base.RuntimeConfigurationObject">RuntimeConfigurationObject</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScalePrimitive(ScaleType, ABC):

    @classmethod
    def generate_type_decomposition(cls, _recursion_level: int = 0, max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE):
        return cls.__name__.lower()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bool" href="types.html#scalecodec.types.Bool">Bool</a></li>
<li><a title="scalecodec.types.F32" href="types.html#scalecodec.types.F32">F32</a></li>
<li><a title="scalecodec.types.F64" href="types.html#scalecodec.types.F64">F64</a></li>
<li><a title="scalecodec.types.H160" href="types.html#scalecodec.types.H160">H160</a></li>
<li><a title="scalecodec.types.H256" href="types.html#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.types.H512" href="types.html#scalecodec.types.H512">H512</a></li>
<li><a title="scalecodec.types.I128" href="types.html#scalecodec.types.I128">I128</a></li>
<li><a title="scalecodec.types.I16" href="types.html#scalecodec.types.I16">I16</a></li>
<li><a title="scalecodec.types.I256" href="types.html#scalecodec.types.I256">I256</a></li>
<li><a title="scalecodec.types.I32" href="types.html#scalecodec.types.I32">I32</a></li>
<li><a title="scalecodec.types.I64" href="types.html#scalecodec.types.I64">I64</a></li>
<li><a title="scalecodec.types.I8" href="types.html#scalecodec.types.I8">I8</a></li>
<li><a title="scalecodec.types.U128" href="types.html#scalecodec.types.U128">U128</a></li>
<li><a title="scalecodec.types.U16" href="types.html#scalecodec.types.U16">U16</a></li>
<li><a title="scalecodec.types.U256" href="types.html#scalecodec.types.U256">U256</a></li>
<li><a title="scalecodec.types.U32" href="types.html#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.types.U64" href="types.html#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.types.U8" href="types.html#scalecodec.types.U8">U8</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.base.ScalePrimitive.scale_info_type"><code class="name">var <span class="ident">scale_info_type</span> : GenericRegistryType</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scalecodec.base.ScalePrimitive.generate_type_decomposition"><code class="name flex">
<span>def <span class="ident">generate_type_decomposition</span></span>(<span>max_recursion: int = 9)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_type_decomposition(cls, _recursion_level: int = 0, max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE):
    return cls.__name__.lower()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.get_decoder_class" href="#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.base.ScaleType"><code class="flex name class">
<span>class <span class="ident">ScaleType</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None, runtime_config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code><a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>VersionedMetadata</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code><a title="scalecodec.base.RuntimeConfigurationObject" href="#scalecodec.base.RuntimeConfigurationObject">RuntimeConfigurationObject</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScaleType(ScaleDecoder, ABC):

    scale_info_type: &#39;GenericRegistryType&#39; = None

    def __init__(self, data=None, sub_type=None, metadata=None, runtime_config=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        data: ScaleBytes
        sub_type: str
        metadata: VersionedMetadata
        runtime_config: RuntimeConfigurationObject
        &#34;&#34;&#34;
        self.metadata = metadata

        # Container for meta information
        self.meta_info: dict = {}

        if not data:
            data = ScaleBytes(bytearray())
        super().__init__(data, sub_type, runtime_config=runtime_config)

    def __getitem__(self, item):
        return self.value_object[item]

    def __iter__(self):
        for item in self.value_object:
            yield item

    def __eq__(self, other):
        if isinstance(other, ScaleType):
            return other.value_serialized == self.value_serialized
        else:
            return other == self.value_serialized

    def __gt__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &gt; other.value_serialized
        else:
            return self.value_serialized &gt; other

    def __ge__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &gt;= other.value_serialized
        else:
            return self.value_serialized &gt;= other

    def __lt__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &lt; other.value_serialized
        else:
            return self.value_serialized &lt; other

    def __le__(self, other):
        if isinstance(other, ScaleType):
            return self.value_serialized &lt;= other.value_serialized
        else:
            return self.value_serialized &lt;= other

    @classmethod
    def generate_type_decomposition(cls, _recursion_level: int = 0, max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE):
        return cls.__name__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleDecoder" href="#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScalePrimitive" href="#scalecodec.base.ScalePrimitive">ScalePrimitive</a></li>
<li><a title="scalecodec.types.BTreeSet" href="types.html#scalecodec.types.BTreeSet">BTreeSet</a></li>
<li><a title="scalecodec.types.BitVec" href="types.html#scalecodec.types.BitVec">BitVec</a></li>
<li><a title="scalecodec.types.Bytes" href="types.html#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.types.CallBytes" href="types.html#scalecodec.types.CallBytes">CallBytes</a></li>
<li><a title="scalecodec.types.Compact" href="types.html#scalecodec.types.Compact">Compact</a></li>
<li><a title="scalecodec.types.Enum" href="types.html#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.types.Era" href="types.html#scalecodec.types.Era">Era</a></li>
<li><a title="scalecodec.types.FixedLengthArray" href="types.html#scalecodec.types.FixedLengthArray">FixedLengthArray</a></li>
<li><a title="scalecodec.types.GenericAddress" href="types.html#scalecodec.types.GenericAddress">GenericAddress</a></li>
<li><a title="scalecodec.types.GenericBlock" href="types.html#scalecodec.types.GenericBlock">GenericBlock</a></li>
<li><a title="scalecodec.types.GenericCall" href="types.html#scalecodec.types.GenericCall">GenericCall</a></li>
<li><a title="scalecodec.types.GenericExtrinsic" href="types.html#scalecodec.types.GenericExtrinsic">GenericExtrinsic</a></li>
<li><a title="scalecodec.types.HexBytes" href="types.html#scalecodec.types.HexBytes">HexBytes</a></li>
<li><a title="scalecodec.types.Map" href="types.html#scalecodec.types.Map">Map</a></li>
<li><a title="scalecodec.types.Null" href="types.html#scalecodec.types.Null">Null</a></li>
<li><a title="scalecodec.types.Option" href="types.html#scalecodec.types.Option">Option</a></li>
<li><a title="scalecodec.types.OptionBytes" href="types.html#scalecodec.types.OptionBytes">OptionBytes</a></li>
<li><a title="scalecodec.types.RawBytes" href="types.html#scalecodec.types.RawBytes">RawBytes</a></li>
<li><a title="scalecodec.types.Set" href="types.html#scalecodec.types.Set">Set</a></li>
<li><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.types.Tuple" href="types.html#scalecodec.types.Tuple">Tuple</a></li>
<li><a title="scalecodec.types.TypeNotSupported" href="types.html#scalecodec.types.TypeNotSupported">TypeNotSupported</a></li>
<li><a title="scalecodec.types.Vec" href="types.html#scalecodec.types.Vec">Vec</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.base.ScaleType.scale_info_type"><code class="name">var <span class="ident">scale_info_type</span> : GenericRegistryType</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scalecodec.base.ScaleType.generate_type_decomposition"><code class="name flex">
<span>def <span class="ident">generate_type_decomposition</span></span>(<span>max_recursion: int = 9)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_type_decomposition(cls, _recursion_level: int = 0, max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE):
    return cls.__name__</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleDecoder" href="#scalecodec.base.ScaleDecoder">ScaleDecoder</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleDecoder.get_decoder_class" href="#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.base.Singleton"><code class="flex name class">
<span>class <span class="ident">Singleton</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>type(object_or_name, bases, dict)
type(object) -&gt; the object's type
type(name, bases, dict) -&gt; a new type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):

        if &#39;config_id&#39; in kwargs:
            instance_key = kwargs[&#39;config_id&#39;]
        else:
            instance_key = cls

        if instance_key not in cls._instances:
            cls._instances[instance_key] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[instance_key]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scalecodec" href="index.html">scalecodec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scalecodec.base.RuntimeConfiguration" href="#scalecodec.base.RuntimeConfiguration">RuntimeConfiguration</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.base.RuntimeConfigurationObject" href="#scalecodec.base.RuntimeConfigurationObject">RuntimeConfigurationObject</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.add_contract_metadata_dict_to_type_registry" href="#scalecodec.base.RuntimeConfigurationObject.add_contract_metadata_dict_to_type_registry">add_contract_metadata_dict_to_type_registry</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.add_portable_registry" href="#scalecodec.base.RuntimeConfigurationObject.add_portable_registry">add_portable_registry</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.all_subclasses" href="#scalecodec.base.RuntimeConfigurationObject.all_subclasses">all_subclasses</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.clear_type_registry" href="#scalecodec.base.RuntimeConfigurationObject.clear_type_registry">clear_type_registry</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.convert_type_string" href="#scalecodec.base.RuntimeConfigurationObject.convert_type_string">convert_type_string</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.create_scale_object" href="#scalecodec.base.RuntimeConfigurationObject.create_scale_object">create_scale_object</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.get_decoder_class" href="#scalecodec.base.RuntimeConfigurationObject.get_decoder_class">get_decoder_class</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.get_decoder_class_for_scale_info_definition" href="#scalecodec.base.RuntimeConfigurationObject.get_decoder_class_for_scale_info_definition">get_decoder_class_for_scale_info_definition</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.get_runtime_id_from_upgrades" href="#scalecodec.base.RuntimeConfigurationObject.get_runtime_id_from_upgrades">get_runtime_id_from_upgrades</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.set_active_spec_version_id" href="#scalecodec.base.RuntimeConfigurationObject.set_active_spec_version_id">set_active_spec_version_id</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.set_runtime_upgrades_head" href="#scalecodec.base.RuntimeConfigurationObject.set_runtime_upgrades_head">set_runtime_upgrades_head</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.update_from_scale_info_types" href="#scalecodec.base.RuntimeConfigurationObject.update_from_scale_info_types">update_from_scale_info_types</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.update_type_registry" href="#scalecodec.base.RuntimeConfigurationObject.update_type_registry">update_type_registry</a></code></li>
<li><code><a title="scalecodec.base.RuntimeConfigurationObject.update_type_registry_types" href="#scalecodec.base.RuntimeConfigurationObject.update_type_registry_types">update_type_registry_types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.base.ScaleBytes" href="#scalecodec.base.ScaleBytes">ScaleBytes</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.base.ScaleBytes.get_next_bytes" href="#scalecodec.base.ScaleBytes.get_next_bytes">get_next_bytes</a></code></li>
<li><code><a title="scalecodec.base.ScaleBytes.get_remaining_bytes" href="#scalecodec.base.ScaleBytes.get_remaining_bytes">get_remaining_bytes</a></code></li>
<li><code><a title="scalecodec.base.ScaleBytes.get_remaining_length" href="#scalecodec.base.ScaleBytes.get_remaining_length">get_remaining_length</a></code></li>
<li><code><a title="scalecodec.base.ScaleBytes.reset" href="#scalecodec.base.ScaleBytes.reset">reset</a></code></li>
<li><code><a title="scalecodec.base.ScaleBytes.to_hex" href="#scalecodec.base.ScaleBytes.to_hex">to_hex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.base.ScaleDecoder" href="#scalecodec.base.ScaleDecoder">ScaleDecoder</a></code></h4>
<ul class="two-column">
<li><code><a title="scalecodec.base.ScaleDecoder.build_type_mapping" href="#scalecodec.base.ScaleDecoder.build_type_mapping">build_type_mapping</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.convert_type" href="#scalecodec.base.ScaleDecoder.convert_type">convert_type</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.decode" href="#scalecodec.base.ScaleDecoder.decode">decode</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.encode" href="#scalecodec.base.ScaleDecoder.encode">encode</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.get_decoder_class" href="#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.get_next_bool" href="#scalecodec.base.ScaleDecoder.get_next_bool">get_next_bool</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.get_next_bytes" href="#scalecodec.base.ScaleDecoder.get_next_bytes">get_next_bytes</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.get_next_u8" href="#scalecodec.base.ScaleDecoder.get_next_u8">get_next_u8</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.get_remaining_bytes" href="#scalecodec.base.ScaleDecoder.get_remaining_bytes">get_remaining_bytes</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.get_used_bytes" href="#scalecodec.base.ScaleDecoder.get_used_bytes">get_used_bytes</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.is_primitive" href="#scalecodec.base.ScaleDecoder.is_primitive">is_primitive</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.process" href="#scalecodec.base.ScaleDecoder.process">process</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.process_encode" href="#scalecodec.base.ScaleDecoder.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.process_type" href="#scalecodec.base.ScaleDecoder.process_type">process_type</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.runtime_config" href="#scalecodec.base.ScaleDecoder.runtime_config">runtime_config</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.serialize" href="#scalecodec.base.ScaleDecoder.serialize">serialize</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.sub_type" href="#scalecodec.base.ScaleDecoder.sub_type">sub_type</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.type_mapping" href="#scalecodec.base.ScaleDecoder.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.type_string" href="#scalecodec.base.ScaleDecoder.type_string">type_string</a></code></li>
<li><code><a title="scalecodec.base.ScaleDecoder.value" href="#scalecodec.base.ScaleDecoder.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.base.ScalePrimitive" href="#scalecodec.base.ScalePrimitive">ScalePrimitive</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.base.ScalePrimitive.generate_type_decomposition" href="#scalecodec.base.ScalePrimitive.generate_type_decomposition">generate_type_decomposition</a></code></li>
<li><code><a title="scalecodec.base.ScalePrimitive.scale_info_type" href="#scalecodec.base.ScalePrimitive.scale_info_type">scale_info_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.base.ScaleType" href="#scalecodec.base.ScaleType">ScaleType</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.base.ScaleType.generate_type_decomposition" href="#scalecodec.base.ScaleType.generate_type_decomposition">generate_type_decomposition</a></code></li>
<li><code><a title="scalecodec.base.ScaleType.scale_info_type" href="#scalecodec.base.ScaleType.scale_info_type">scale_info_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.base.Singleton" href="#scalecodec.base.Singleton">Singleton</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>