{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#description","title":"Description","text":"<p>Substrate uses a lightweight and efficient encoding and decoding program to optimize how data is sent and received over the network. The program used to serialize and deserialize data is called the SCALE codec, with SCALE being an acronym for Simple Concatenated Aggregate Little-Endian.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install scalecodec\n</code></pre>"},{"location":"#examples-of-different-types","title":"Examples of different types","text":"Type Description Example SCALE decoding value SCALE encoded value <code>bool</code> Boolean values are encoded using the least significant bit of a single byte. <code>True</code> <code>0x01</code> <code>u16</code> Basic integers are encoded using a fixed-width little-endian (LE) format. <code>42</code> <code>0x2a00</code> <code>Compact</code> A \"compact\" or general integer encoding is sufficient for encoding large integers (up to 2**536) and is more efficient at encoding most values than the fixed-width version. (Though for single-byte values, the fixed-width integer is never worse.) <code>0</code> <code>0x00</code> <code>1</code> <code>0x04</code> <code>42</code> <code>0xa8</code> <code>69</code> <code>0x1501</code> <code>100000000000000</code> <code>0x0b00407a10f35a</code> <code>Vec</code> A collection of same-typed values is encoded, prefixed with a compact encoding of the number of items, followed by each item's encoding concatenated in turn. <code>[4, 8, 15, 16, 23, 42]</code> <code>0x18040008000f00100017002a00</code> <code>BitVec</code> A sequence of bools, represented in a more space efficient bit format <code>0b00000010_01111101</code> <code>0x287d02</code> <code>str</code>,<code>Bytes</code>, <code>String</code> Strings are Vectors of bytes (<code>Vec&lt;u8&gt;</code>) containing a valid UTF8 sequence. <code>\"Test\"</code> <code>0x1054657374</code> <code>b\"Test\"</code> <code>0x1054657374</code> <code>[84, 101, 115, 116]</code> <code>0x1054657374</code> <code>[u8; 4]</code> Fixed sized array of in this case an <code>u8</code> <code>b\"babe\"</code> <code>0x62616265</code> <code>\"0x62616265\"</code> <code>0x62616265</code> <code>[98, 97, 98, 101]</code> <code>0x62616265</code> <code>AccountId</code> An SS58 formatted representation of an account. See also the SS58 util functions <code>\"5GDyPHLVHcQYPTWfygtPY eogQjyZy7J9fsi4brPhgEFq4pcv\"</code> <code>0xb80269ec500e458a630846b99105c397 ee574125823d6f4388e9c7572e115c05</code> <code>Enum</code> Example: <code>enum IntOrBool { Int(u8), Bool(bool),}</code> A fixed number of variants, each mutually exclusive and potentially implying a further value or series of values. Encoded as the first byte identifying the index of the variant that the value is. Any further bytes are used to encode any data that the variant implies. Thus, no more than 256 variants are supported. <code>{'Int': 8}</code> <code>0x002a</code> <code>{'Bool': True}</code> <code>0x0101</code> <code>Struct</code> Example: <code>struct Motion { pub votes: Vec&lt;AccountId&gt;, pub id: u32 }</code> For structures, the values are named, but that is irrelevant for the encoding (names are ignored - only order matters). All containers store elements consecutively. The order of the elements is not fixed, depends on the container, and cannot be relied on at decoding. This implicitly means that decoding some byte-array into a specified structure that enforces an order and then re-encoding it could result in a different byte array than the original that was decoded. <code>{\"votes\": [\"5GDyPHLVHcQYPTWfygtPYeo gQjyZy7J9fsi4brPhgEFq4pcv\"], \"id\": 4}</code> <code>0x04b80269ec500e458a630846b99105c397ee57 4125823d6f4388e9c7572e115c0504000000</code>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#code-examples","title":"Code Examples","text":""},{"location":"examples/#encode-a-call","title":"Encode a Call","text":"<pre><code>runtime_config = RuntimeConfigurationObject()\n\n# This types are all hardcoded types needed to decode metadata types\nruntime_config.update_type_registry(load_type_registry_preset(name=\"core\"))\n\n# Decode retrieved metadata from the RPC\nmetadata = runtime_config.create_scale_object(\n    'MetadataVersioned', data=ScaleBytes(response.get('result'))\n)\nmetadata.decode()\n\n# Add the embedded type registry to the runtime config\nruntime_config.add_portable_registry(metadata)\n\ncall = runtime_config.create_scale_object(\n    \"Call\", metadata=metadata\n)\ncall.encode({\n    \"call_module\": \"Balances\",\n    \"call_function\": \"transfer\",\n    \"call_args\": {\"dest\": \"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\", \"value\": 3},\n})\n</code></pre>"},{"location":"examples/#decode-the-result-of-a-state_getstorageat-rpc-call","title":"Decode the result of a <code>state_getStorageAt</code> RPC call","text":"<pre><code>event_data = \"0x2000000000000000b0338609000000000200000001000000000080b2e60e0000000002000000020000000003be1957935299d0be2f35b8856751feab95fc7089239366b52b72ca98249b94300000020000000500be1957935299d0be2f35b8856751feab95fc7089239366b52b72ca98249b943000264d2823000000000000000000000000000200000005027a9650a6bd43f1e0b4546affb88f8c14213e1fb60512692c2b39fbfcfc56b703be1957935299d0be2f35b8856751feab95fc7089239366b52b72ca98249b943000264d2823000000000000000000000000000200000013060c4c700700000000000000000000000000000200000005047b8441d5110c178c29be709793a41d73ae8b3119a971b18fbd20945ea5d622f00313dc01000000000000000000000000000002000000000010016b0b00000000000000\"\n\nsystem_pallet = metadata.get_metadata_pallet(\"System\")\nevent_storage_function = system_pallet.get_storage_function(\"Events\")\n\nevent = runtime_config.create_scale_object(\n    event_storage_function.get_value_type_string(), metadata=metadata\n)\nprint(event.decode(ScaleBytes(event_data)))\n</code></pre>"},{"location":"examples/#generate-type-decomposition-information","title":"Generate type decomposition information","text":"<p>The function <code>generate_type_decomposition</code> can be  used when more information is needed how to encode a certain SCALE type:  </p> <p>Example 1 <pre><code>scale_obj = runtime_config.create_scale_object(\"RawBabePreDigest\")\n\ntype_info = scale_obj.generate_type_decomposition()\n\nprint(type_info)\n# {\n#   'Phantom': None, \n#   'Primary': {'authority_index': 'u32', 'slot_number': 'u64', 'vrf_output': '[u8; 32]', 'vrf_proof': '[u8; 64]'}, \n#   'SecondaryPlain': {'authority_index': 'u32', 'slot_number': 'u64'}, \n#   'SecondaryVRF': {'authority_index': 'u32', 'slot_number': 'u64', 'vrf_output': '[u8; 32]', 'vrf_proof': '[u8; 64]'}\n# }\n</code></pre></p> <p>Example 2 <pre><code>pallet = metadata.get_metadata_pallet(\"Tokens\")\nstorage_function = pallet.get_storage_function(\"TotalIssuance\")\n\nparam_type_string = storage_function.get_params_type_string()\nparam_type_obj = runtime_config.create_scale_object(param_type_string[0])\n\ntype_info = param_type_obj.generate_type_decomposition()\n\nprint(type_info)\n# [{\n#   'Token': ('ACA', 'AUSD', 'DOT', 'LDOT', 'RENBTC', 'CASH', 'KAR', 'KUSD', 'KSM', 'LKSM', 'TAI', 'BNC', 'VSKSM', 'PHA', 'KINT', 'KBTC'), \n#   'DexShare': ({'Token': ('ACA', 'AUSD', 'DOT', 'LDOT', 'RENBTC', 'CASH', 'KAR', 'KUSD', 'KSM', 'LKSM', 'TAI', 'BNC', 'VSKSM', 'PHA', 'KINT', 'KBTC'), 'Erc20': '[u8; 20]', 'LiquidCrowdloan': 'u32', 'ForeignAsset': 'u16'}, {'Token': ('ACA', 'AUSD', 'DOT', 'LDOT', 'RENBTC', 'CASH', 'KAR', 'KUSD', 'KSM', 'LKSM', 'TAI', 'BNC', 'VSKSM', 'PHA', 'KINT', 'KBTC'), 'Erc20': '[u8; 20]', 'LiquidCrowdloan': 'u32', 'ForeignAsset': 'u16'}), \n#   'Erc20': '[u8; 20]', \n#   'StableAssetPoolToken': 'u32', \n#   'LiquidCrowdloan': 'u32', \n#   'ForeignAsset': 'u16'\n# }]\n</code></pre></p> <p>In the above examples are simple value <code>Enums</code> representation as a <code>tuple</code> of possible values and complex <code>Enums</code> as  a <code>dict</code>.</p>"},{"location":"examples/#examples-prior-to-metadatav14","title":"Examples (prior to MetadataV14)","text":""},{"location":"examples/#decode-a-scale-encoded-compactbalance","title":"Decode a SCALE-encoded Compact\\&lt;Balance&gt;","text":"<pre><code>RuntimeConfiguration().update_type_registry(load_type_registry_preset(\"legacy\"))\nRuntimeConfiguration().update_type_registry(load_type_registry_preset(\"kusama\"))\nobj = RuntimeConfiguration().create_scale_object('Compact&lt;Balance&gt;', data=ScaleBytes(\"0x130080cd103d71bc22\"))\nobj.decode()\nprint(obj.value)\n</code></pre>"},{"location":"examples/#encode-to-compactbalance","title":"Encode to Compact\\&lt;Balance&gt;","text":"<pre><code>RuntimeConfiguration().update_type_registry(load_type_registry_preset(\"legacy\"))\nobj = RuntimeConfiguration().create_scale_object('Compact&lt;Balance&gt;')\nscale_data = obj.encode(2503000000000000000)\nprint(scale_data)\n</code></pre>"},{"location":"examples/#encode-to-vecbytes","title":"Encode to Vec\\&lt;Bytes&gt;","text":"<pre><code>RuntimeConfiguration().update_type_registry(load_type_registry_preset(\"legacy\"))\nvalue = ['test', 'vec']\nobj = RuntimeConfiguration().create_scale_object('Vec&lt;Bytes&gt;')\nscale_data = obj.encode(value)\nprint(scale_data)\n</code></pre>"},{"location":"examples/#add-custom-types-to-type-registry","title":"Add custom types to type registry","text":"<pre><code>RuntimeConfiguration().update_type_registry(load_type_registry_preset(\"legacy\"))\n\ncustom_types = {\n    \"types\": {\n        \"MyCustomType\": \"u32\",\n        \"CustomNextAuthority\": {\n          \"type\": \"struct\",\n          \"type_mapping\": [\n             [\"AuthorityId\", \"AuthorityId\"],\n             [\"weight\", \"AuthorityWeight\"]\n          ]\n        }\n    }   \n}\n\nRuntimeConfiguration().update_type_registry(custom_types)\n</code></pre>"},{"location":"examples/#or-from-a-custom-json-file","title":"Or from a custom JSON file","text":"<pre><code>RuntimeConfiguration().update_type_registry(load_type_registry_preset(\"legacy\"))\nRuntimeConfiguration().update_type_registry(load_type_registry_file(\"/path/to/type_registry.json\"))\n</code></pre>"},{"location":"examples/#multiple-runtime-configurations","title":"Multiple runtime configurations","text":"<p>By default a singleton is used to maintain the configuration, for multiple instances: </p> <pre><code># Kusama runtime config\nruntime_config_kusama = RuntimeConfigurationObject()\nruntime_config_kusama.update_type_registry(load_type_registry_preset(\"legacy\"))\nruntime_config_kusama.update_type_registry(load_type_registry_preset(\"kusama\"))\n\n\n# Polkadot runtime config\nruntime_config_polkadot = RuntimeConfigurationObject()\nruntime_config_polkadot.update_type_registry(load_type_registry_preset(\"legacy\"))\nruntime_config_polkadot.update_type_registry(load_type_registry_preset(\"polkadot\"))\n\n# Decode extrinsic using Kusama runtime configuration\nextrinsic = runtime_config_kusama.create_scale_object(\n    type_string='Extrinsic', \n    metadata=metadata_decoder\n)\nextrinsic.decode(ScaleBytes(extrinsic_data))\n</code></pre>"},{"location":"reference/","title":"Function Reference","text":""},{"location":"reference/#scalecodec.base.RuntimeConfigurationObject","title":"<code>RuntimeConfigurationObject</code>","text":"<p>Container for runtime configuration, for example type definitions and runtime upgrade information</p>"},{"location":"reference/#scalecodec.base.RuntimeConfigurationObject.get_decoder_class","title":"<code>get_decoder_class(type_string: Union[str, dict])</code>","text":"<p>Lookup and return a ScaleDecoder class for given <code>type_string</code></p> <p>Parameters:</p> Name Type Description Default <code>type_string</code> <code>Union[str, dict]</code> required <p>Returns:</p> Type Description <code>ScaleDecoder</code>"},{"location":"reference/#scalecodec.base.RuntimeConfigurationObject.create_scale_object","title":"<code>create_scale_object(type_string: str, data: Optional[ScaleBytes] = None, **kwargs) -&gt; ScaleType</code>","text":"<p>Creates a new <code>ScaleType</code> object with given type_string, for example 'u32', 'Bytes' or 'scale_info::2' (scale_info:: prefixed types are defined in the <code>PortableRegistry</code> object of the runtime metadata.)</p> <p>Parameters:</p> Name Type Description Default <code>type_string</code> <code>str</code> required <code>data</code> <code>Optional[ScaleBytes]</code> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>ScaleType</code>"},{"location":"reference/#scalecodec.base.RuntimeConfigurationObject.get_runtime_id_from_upgrades","title":"<code>get_runtime_id_from_upgrades(block_number: int) -&gt; Optional[int]</code>","text":"<p>Retrieve runtime_id for given block_number if runtime_upgrades are specified in the type registry</p> <p>Parameters:</p> Name Type Description Default <code>block_number</code> <code>int</code> required <p>Returns:</p> Type Description <code>Runtime id</code>"},{"location":"reference/#scalecodec.base.RuntimeConfigurationObject.set_runtime_upgrades_head","title":"<code>set_runtime_upgrades_head(block_number: int)</code>","text":"<p>Sets head for given block_number to last runtime_id in runtime_upgrades cache</p> <p>Parameters:</p> Name Type Description Default <code>block_number</code> <code>int</code> required"},{"location":"reference/#scalecodec.base.ScaleBytes","title":"<code>ScaleBytes</code>","text":"<p>Representation of SCALE encoded Bytes.</p>"},{"location":"reference/#scalecodec.base.ScaleBytes.__init__","title":"<code>__init__(data: Union[str, bytes, bytearray])</code>","text":"<p>Constructs a SCALE bytes-stream with provided <code>data</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes, bytearray]</code> required"},{"location":"reference/#scalecodec.base.ScaleBytes.get_next_bytes","title":"<code>get_next_bytes(length: int) -&gt; bytearray</code>","text":"<p>Retrieve <code>length</code> amount of bytes of the stream</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> required <p>Returns:</p> Type Description <code>bytearray</code>"},{"location":"reference/#scalecodec.base.ScaleBytes.get_remaining_bytes","title":"<code>get_remaining_bytes() -&gt; bytearray</code>","text":"<p>Retrieves all remaining bytes from the stream</p>"},{"location":"reference/#scalecodec.base.ScaleBytes.get_remaining_length","title":"<code>get_remaining_length() -&gt; int</code>","text":"<p>Returns how many bytes are left in the stream</p> <p>Returns:</p> Type Description <code>int</code>"},{"location":"reference/#scalecodec.base.ScaleBytes.reset","title":"<code>reset()</code>","text":"<p>Resets the pointer of the stream to the beginning</p>"},{"location":"reference/#scalecodec.base.ScaleBytes.to_hex","title":"<code>to_hex() -&gt; str</code>","text":"<p>Return a hex-string (e.g. \"0x00\") representation of the byte-stream</p> <p>Returns:</p> Type Description <code>str</code>"},{"location":"reference/#scalecodec.base.ScaleDecoder","title":"<code>ScaleDecoder</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for all SCALE decoding/encoding</p>"},{"location":"reference/#scalecodec.base.ScaleDecoder.__init__","title":"<code>__init__(data: ScaleBytes, sub_type: str = None, runtime_config: RuntimeConfigurationObject = None)</code>","text":"<p>Constructs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ScaleBytes</code> required <code>sub_type</code> <code>str</code> <code>None</code> <code>runtime_config</code> <code>RuntimeConfigurationObject</code> <code>None</code>"},{"location":"reference/#scalecodec.base.ScaleDecoder.get_decoder_class","title":"<code>get_decoder_class(type_string, data = None, runtime_config = None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>type_string</code> required <code>data</code> <code>None</code> <code>runtime_config</code> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>ScaleType</code>"},{"location":"reference/#scalecodec.base.ScaleType","title":"<code>ScaleType</code>","text":"<p>         Bases: <code>ScaleDecoder</code>, <code>ABC</code></p> <p>Base class for all SCALE types</p>"},{"location":"reference/#scalecodec.base.ScaleType.__init__","title":"<code>__init__(data = None, sub_type = None, metadata = None, runtime_config = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>None</code> <code>sub_type</code> <code>None</code> <code>metadata</code> <code>None</code> <code>runtime_config</code> <code>None</code>"},{"location":"reference/#scalecodec.base.ScalePrimitive","title":"<code>ScalePrimitive</code>","text":"<p>         Bases: <code>ScaleType</code>, <code>ABC</code></p> <p>A SCALE representation of a RUST primitive</p>"},{"location":"reference/#scalecodec.types.Compact","title":"<code>Compact</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>A space efficient type to encoding fixed-width integers</p>"},{"location":"reference/#scalecodec.types.CompactU32","title":"<code>CompactU32</code>","text":"<p>         Bases: <code>Compact</code></p> <p>Specialized composite implementation for performance improvement</p>"},{"location":"reference/#scalecodec.types.Option","title":"<code>Option</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>Option is a type that represents an optional value, which can be either Some(value) if a value is present or None if it is absent, allowing for safe handling of null or missing values without causing runtime errors.</p>"},{"location":"reference/#scalecodec.types.Bytes","title":"<code>Bytes</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>A variable collection of bytes, stored as an <code>Vec&lt;u8&gt;</code></p>"},{"location":"reference/#scalecodec.types.U8","title":"<code>U8</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Unsigned 8-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.U16","title":"<code>U16</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Unsigned 16-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.U32","title":"<code>U32</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Unsigned 32-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.U64","title":"<code>U64</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Unsigned 64-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.U128","title":"<code>U128</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Unsigned 128-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.U256","title":"<code>U256</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Unsigned 256-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.I8","title":"<code>I8</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Signed 8-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.I16","title":"<code>I16</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Signed 16-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.I32","title":"<code>I32</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Signed 32-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.I64","title":"<code>I64</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Signed 64-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.I128","title":"<code>I128</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Signed 128-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.I256","title":"<code>I256</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Signed 256-bit int type, encoded in little-endian (LE) format</p>"},{"location":"reference/#scalecodec.types.H160","title":"<code>H160</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Fixed-size uninterpreted hash type with 20 bytes (160 bits) size.</p>"},{"location":"reference/#scalecodec.types.H256","title":"<code>H256</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Fixed-size uninterpreted hash type with 32 bytes (256 bits) size.</p>"},{"location":"reference/#scalecodec.types.H512","title":"<code>H512</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Fixed-size uninterpreted hash type with 64 bytes (512 bits) size.</p>"},{"location":"reference/#scalecodec.types.Struct","title":"<code>Struct</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>A struct is a composite data type that groups together zero or more values with various types into a single object</p>"},{"location":"reference/#scalecodec.types.Set","title":"<code>Set</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>The Set type in Substrate is an unordered collection that contains unique elements. It is implemented using a binary search tree, allowing for efficient insertion, removal, and lookup operations.</p>"},{"location":"reference/#scalecodec.types.Era","title":"<code>Era</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>An Era represents a range of blocks in which a transaction is allowed to be executed.</p> <p>An Era may either be \"immortal\", in which case the transaction is always valid, or \"mortal\", in which case the transaction has a defined start block and period in which it is valid.</p>"},{"location":"reference/#scalecodec.types.Era.is_immortal","title":"<code>is_immortal() -&gt; bool</code>","text":"<p>Returns true if the era is immortal, false if mortal.</p>"},{"location":"reference/#scalecodec.types.Era.birth","title":"<code>birth(current: int) -&gt; int</code>","text":"<p>Gets the block number of the start of the era given, with <code>current</code> as the reference block number for the era, normally included as part of the transaction.</p>"},{"location":"reference/#scalecodec.types.Era.death","title":"<code>death(current: int) -&gt; int</code>","text":"<p>Gets the block number of the first block at which the era has ended.</p> <p>If the era is immortal, 2**64 - 1 (the maximum unsigned 64-bit integer) is returned.</p>"},{"location":"reference/#scalecodec.types.Bool","title":"<code>Bool</code>","text":"<p>         Bases: <code>ScalePrimitive</code></p> <p>Boolean type</p>"},{"location":"reference/#scalecodec.types.GenericAccountId","title":"<code>GenericAccountId</code>","text":"<p>         Bases: <code>H256</code></p> <p>An SS58 formatted representation of an account</p>"},{"location":"reference/#scalecodec.types.GenericEthereumAccountId","title":"<code>GenericEthereumAccountId</code>","text":"<p>         Bases: <code>H160</code></p> <p>Representation of an Ethereum address, internally a <code>H160</code></p>"},{"location":"reference/#scalecodec.types.GenericAccountIndex","title":"<code>GenericAccountIndex</code>","text":"<p>         Bases: <code>U32</code></p> <p>The AccountIndex type Substrate represents an account index, which is a unique identifier assigned to an account in the Substrate runtime.</p>"},{"location":"reference/#scalecodec.types.Vec","title":"<code>Vec</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>A Vec in RUST is a dynamically resizable array that can hold a sequence of elements of the same type, allowing for efficient random access and insertion or removal of elements at the end of the vector.</p>"},{"location":"reference/#scalecodec.types.BoundedVec","title":"<code>BoundedVec</code>","text":"<p>         Bases: <code>Vec</code></p> <p>BoundedVec is a fixed-size vector used in Substrate, with a maximum number of elements that can be added. It is used in cases where a fixed-size buffer is required, such as in the case of the transaction input/output limit in the Substrate runtime.</p>"},{"location":"reference/#scalecodec.types.BitVec","title":"<code>BitVec</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes</p>"},{"location":"reference/#scalecodec.types.Enum","title":"<code>Enum</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>A fixed number of variants, each mutually exclusive and potentially implying a further value or series of values.</p>"},{"location":"reference/#scalecodec.types.Conviction","title":"<code>Conviction</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Conviction represents a measure of the degree of confidence or trust that a stakeholder has in a particular proposal in the Substrate runtime. It is used to determine the voting power of a stakeholder for a particular proposal, with higher conviction leading to more voting power.</p>"},{"location":"reference/#scalecodec.types.OpaqueCall","title":"<code>OpaqueCall</code>","text":"<p>         Bases: <code>Bytes</code></p> <p>A Bytes representation of a <code>Call</code>, without having to decode the contents</p>"},{"location":"reference/#scalecodec.types.FixedLengthArray","title":"<code>FixedLengthArray</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>Fixed sized array of specified subtype e.g. [u8; 8]</p>"},{"location":"reference/#scalecodec.types.GenericMultiAddress","title":"<code>GenericMultiAddress</code>","text":"<p>         Bases: <code>Enum</code></p> <p>MultiAddress is a type used in the Substrate runtime to represent an address that can be expressed in multiple ways, such as an account ID, a public key, or a human-readable name, allowing for flexible addressing and storage of data.</p>"},{"location":"reference/#scalecodec.types.GenericMetadataAll","title":"<code>GenericMetadataAll</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum that contains a Metadata version.</p> <p>E.g.  <code>{\"V14\": MetadataV14}</code></p>"},{"location":"reference/#scalecodec.types.GenericMetadataVersioned","title":"<code>GenericMetadataVersioned</code>","text":"<p>         Bases: <code>Tuple</code></p> <p>Tuple that contains a backwards compatible MetadataAll type</p>"},{"location":"reference/#scalecodec.types.GenericVariant","title":"<code>GenericVariant</code>","text":"<p>         Bases: <code>Struct</code></p>"},{"location":"reference/#scalecodec.types.GenericVariant.get_param_info","title":"<code>get_param_info(max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE) -&gt; dict</code>","text":"<p>Generates a dictionary of all possible params with their decomposition information</p> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/#scalecodec.types.ScaleInfoStorageEntryMetadata","title":"<code>ScaleInfoStorageEntryMetadata</code>","text":"<p>         Bases: <code>GenericStorageEntryMetadata</code></p>"},{"location":"reference/#scalecodec.types.ScaleInfoStorageEntryMetadata.get_param_info","title":"<code>get_param_info(max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE) -&gt; list</code>","text":"<p>Return a type decomposition how to format parameters for current storage function</p> <p>Returns:</p> Type Description <code>list</code>"},{"location":"reference/#scalecodec.types.GenericRuntimeCallDefinition","title":"<code>GenericRuntimeCallDefinition</code>","text":"<p>         Bases: <code>Struct</code></p>"},{"location":"reference/#scalecodec.types.GenericRuntimeCallDefinition.get_param_info","title":"<code>get_param_info(max_recursion: int = TYPE_DECOMP_MAX_RECURSIVE) -&gt; list</code>","text":"<p>Return a type decomposition how to format parameters for current storage function</p> <p>Returns:</p> Type Description <code>list</code>"},{"location":"reference/#scalecodec.types.GenericExtrinsic","title":"<code>GenericExtrinsic</code>","text":"<p>         Bases: <code>ScaleType</code></p> <p>The Extrinsic type is used to send transactions from an account to the Substrate runtime, and it can contain one or more calls to the runtime functions.</p>"},{"location":"reference/#scalecodec.types.GenericEvent","title":"<code>GenericEvent</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An Event is a type used to represent a runtime event, which is a signal that indicates that a specific state transition has occurred.</p> <p>It is implemented as a variant enum that contains different types of events, such as system events, runtime events, and custom events, each with its own set of fields that describe the event.</p>"},{"location":"reference/#scalecodec.type_registry.load_type_registry_preset","title":"<code>load_type_registry_preset(name: str, use_remote_preset: bool = False) -&gt; Optional[dict]</code>","text":"<p>Loads a type registry JSON file into a dict</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>use_remote_preset</code> <code>bool</code> <code>False</code>"}]}